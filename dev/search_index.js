var documenterSearchIndex = {"docs":
[{"location":"element_database/#ABAQUS-Element-Database","page":"Element Database","title":"ABAQUS Element Database","text":"This TOML file defines the mapping from ABAQUS element types to generic element topology used by AbaqusReader.jl.","category":"section"},{"location":"element_database/#File-Format","page":"Element Database","title":"File Format","text":"Each element is defined as a TOML table with the following fields:\n\n[ELEMENT_NAME]\nnodes = <number of nodes>\ntype = \"<generic element type>\"\ndescription = \"<optional description>\"","category":"section"},{"location":"element_database/#Fields","page":"Element Database","title":"Fields","text":"nodes (required): Integer specifying the number of nodes in the element\ntype (required): String specifying the mesh topology type that this ABAQUS element maps to\nThe type uses an abbreviated naming convention: ShapePrefix + NodeCount\n\"Tet4\", \"Tet10\" - Tetrahedron with 4 or 10 nodes\n\"Hex8\", \"Hex20\" - Hexahedron with 8 or 20 nodes  \n\"Wedge6\", \"Wedge15\" - Wedge (pentahedron) with 6 or 15 nodes\n\"Tri3\", \"Tri6\" - Triangle with 3 or 6 nodes\n\"Quad4\", \"Quad8\" - Quadrilateral with 4 or 8 nodes\n\"Seg2\", \"Seg3\" - Segment (line) with 2 or 3 nodes\n\"Poi1\" - Point (single node)\nThe number suffix makes it explicit how many nodes the element has\ndescription (optional): String describing the element (useful for documentation)","category":"section"},{"location":"element_database/#Adding-New-Elements","page":"Element Database","title":"Adding New Elements","text":"To add support for a new ABAQUS element type:\n\nFind the ABAQUS element documentation to determine:\nElement name (e.g., C3D8R)\nNumber of nodes (e.g., 8)\nBasic topology (tetrahedral, hexahedral, shell, etc.)\nAdd a new section to this file in the appropriate category:\n\n[YOUR_ELEMENT]\nnodes = X\ntype = \"AppropriateType\"\ndescription = \"Brief description\"\n\nNo code changes needed! The element will be automatically available after restarting Julia.","category":"section"},{"location":"element_database/#Element-Categories","page":"Element Database","title":"Element Categories","text":"The file is organized into sections for easier maintenance:\n\n3D Solid Elements: Tetrahedral, Wedge/Prism, Hexahedral\nCohesive Elements: Interface/cohesive zone elements\nShell Elements: Triangular and Quadrilateral shells\n2D Continuum: Plane stress (CPS), Plane strain (CPE), Axisymmetric (CAX)\nBeam and Truss: Line elements","category":"section"},{"location":"element_database/#Element-Naming-Conventions","page":"Element Database","title":"Element Naming Conventions","text":"ABAQUS uses suffixes to indicate element formulation details:\n\nR = Reduced integration\nH = Hybrid formulation\nI = Incompatible modes\nM = Modified formulation\nE = Enhanced strain\n\nSince AbaqusReader focuses on mesh topology (geometry), elements with the same node count map to the same generic type. For example, C3D8, C3D8R, C3D8H, and C3D8I all map to \"Hex8\" since they're all 8-node hexahedra.","category":"section"},{"location":"element_database/#Contributing","page":"Element Database","title":"Contributing","text":"If you need support for an ABAQUS element that's not in this database:\n\nAdd it to this TOML file following the format above\nAdd a test in test/test_parse_mesh.jl to verify it works\nSubmit a pull request!\n\nThe TOML format makes it easy for the community to expand element support without touching any Julia code.","category":"section"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Overview","page":"API Reference","title":"Overview","text":"AbaqusReader.jl exports the following main functions for working with ABAQUS input files:\n\nFile-based API: abaqus_read_mesh, abaqus_read_model (read from .inp files)\nString-based API: abaqus_parse_mesh, abaqus_parse_model (parse from string buffers)\nElement registration: register_element! (add element types dynamically)\nUtilities: create_surface_elements, abaqus_download","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#Exported-Functions","page":"API Reference","title":"Exported Functions","text":"","category":"section"},{"location":"api/#AbaqusReader.abaqus_read_mesh","page":"API Reference","title":"AbaqusReader.abaqus_read_mesh","text":"abaqus_read_mesh(fn::String) -> Dict\n\nRead ABAQUS .inp file and extract mesh geometry and topology.\n\nThis function performs mesh-only parsing, extracting nodes, elements, sets, and surfaces without parsing materials, boundary conditions, or analysis steps. Use this when you only need the geometric structure of the model.\n\nArguments\n\nfn::String: Path to the ABAQUS input file (.inp)\n\nReturns\n\nA Dict{String, Any} containing:\n\n\"nodes\": Dict{Int, Vector{Float64}} - Node ID â†’ coordinates [x, y, z]\n\"elements\": Dict{Int, Vector{Int}} - Element ID â†’ node connectivity\n\"element_types\": Dict{Int, Symbol} - Element ID â†’ topological type (e.g., :Tet4, :Hex8)\n\"element_codes\": Dict{Int, Symbol} - Element ID â†’ original ABAQUS element name (e.g., :C3D8R, :CPS3)\n\"node_sets\": Dict{String, Vector{Int}} - Node set name â†’ node IDs\n\"element_sets\": Dict{String, Vector{Int}} - Element set name â†’ element IDs\n\"surface_sets\": Dict{String, Vector{Tuple{Int, Symbol}}} - Surface name â†’ (element, face) pairs\n\"surface_types\": Dict{String, Symbol} - Surface name â†’ surface type (e.g., :ELEMENT)\n\nExamples\n\nusing AbaqusReader\n\n# Read mesh from file\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Access node coordinates\ncoords = mesh[\"nodes\"][1]  # [x, y, z] for node 1\n\n# Get element connectivity\nelem_nodes = mesh[\"elements\"][1]  # Node IDs for element 1\n\n# Get topological element type\nelem_type = mesh[\"element_types\"][1]  # e.g., :Hex8\n\n# Get original ABAQUS element code\nelem_code = mesh[\"element_codes\"][1]  # e.g., :C3D8R\n\n# Get nodes in a set\nboundary_nodes = mesh[\"node_sets\"][\"BOUNDARY\"]\n\nSee Also\n\nabaqus_parse_mesh: Parse mesh from string buffer\nabaqus_read_model: Read complete model including materials and boundary conditions\ncreate_surface_elements: Extract surface elements from surface definitions\n\nNotes\n\nSupports 60+ ABAQUS element types (see documentation for full list)\nReturns simple dictionary structure for easy manipulation\nMuch faster than abaqus_read_model when only mesh is needed\nElement types are mapped to generic topology (e.g., C3D8R â†’ :Hex8)\nOriginal ABAQUS element names preserved in element_codes for traceability\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.abaqus_parse_mesh","page":"API Reference","title":"AbaqusReader.abaqus_parse_mesh","text":"abaqus_parse_mesh(content::AbstractString) -> Dict\n\nParse ABAQUS mesh from a string buffer.\n\nThis is the core parsing function that extracts mesh geometry and topology from ABAQUS input file content provided as a string. Use this when you have the content in memory or want to avoid file I/O in tests.\n\nArguments\n\ncontent::AbstractString: ABAQUS input file content as a string\n\nReturns\n\nSame dictionary structure as abaqus_read_mesh:\n\n\"nodes\": Node coordinates\n\"elements\": Element connectivity\n\"element_types\": Topological types\n\"element_codes\": Original ABAQUS element names\n\"node_sets\", \"element_sets\", \"surface_sets\": Named sets\n\nExamples\n\ninp_content = \"\"\"\n*NODE\n1, 0.0, 0.0, 0.0\n2, 1.0, 0.0, 0.0\n*ELEMENT, TYPE=C3D8\n1, 1, 2, 3, 4, 5, 6, 7, 8\n\"\"\"\n\nmesh = abaqus_parse_mesh(inp_content)\n\nSee Also\n\nabaqus_read_mesh: Read mesh from file\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.abaqus_read_model","page":"API Reference","title":"AbaqusReader.abaqus_read_model","text":"abaqus_read_model(fn::String) -> Model\n\nRead complete ABAQUS model including mesh, materials, boundary conditions, and analysis steps.\n\nThis function performs complete model parsing, extracting the entire simulation definition from an ABAQUS input file. Use this when you need to reproduce or analyze the full simulation setup, not just the mesh geometry.\n\nArguments\n\nfn::String: Path to the ABAQUS input file (.inp)\n\nReturns\n\nAn AbaqusReader.Model object with fields:\n\npath::String: Directory containing the input file\nname::String: Model name (basename without extension)\nmesh::Mesh: Mesh object containing all geometric data\nmesh.nodes: Node coordinates\nmesh.elements: Element connectivity\nmesh.element_types: Element type mapping\nmesh.node_sets: Named node sets\nmesh.element_sets: Named element sets\nmesh.surface_sets: Surface definitions\nmaterials::Dict: Material definitions with properties\nEach material may contain elastic, density, plastic, etc.\nproperties::Vector: Section property assignments (linking materials to element sets)\nboundary_conditions::Vector: Prescribed displacements, constraints, etc.\nsteps::Vector: Analysis steps with loads, BCs, and output requests\n\nExamples\n\nusing AbaqusReader\n\n# Read complete model\nmodel = abaqus_read_model(\"simulation.inp\")\n\n# Access mesh (same structure as abaqus_read_mesh)\nnodes = model.mesh.nodes\nelements = model.mesh.elements\n\n# Access material properties\nfor (name, material) in model.materials\n    println(\"Material: $name\")\n    for prop in material.properties\n        if prop isa AbaqusReader.Elastic\n            println(\"  E = $(prop.E), Î½ = $(prop.nu)\")\n        end\n    end\nend\n\n# Iterate through boundary conditions\nfor bc in model.boundary_conditions\n    println(\"BC type: $(bc.kind), data: $(bc.data)\")\nend\n\n# Iterate through analysis steps\nfor step in model.steps\n    println(\"Step type: $(step.kind)\")\n    println(\"  BCs: $(length(step.boundary_conditions))\")\n    println(\"  Outputs: $(length(step.output_requests))\")\nend\n\nSee Also\n\nabaqus_parse_model: Parse model from string buffer\nabaqus_read_mesh: Read only mesh geometry (faster, simpler output)\ncreate_surface_elements: Extract surface elements from model\n\nNotes\n\nSlower than abaqus_read_mesh as it parses the entire model\nReturns structured Model object (not a simple Dict)\nParses most common ABAQUS keywords but not every possible option\nBest suited for \"flat\" input files; structured part/assembly files may have limited support\nUse when you need materials, BCs, loads, or analysis parameters\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.abaqus_parse_model","page":"API Reference","title":"AbaqusReader.abaqus_parse_model","text":"abaqus_parse_model(content::AbstractString) -> Model\n\nParse complete ABAQUS model from a string buffer.\n\nThis is the core parsing function that extracts the entire simulation definition from ABAQUS input file content provided as a string. Use this when you have the content in memory, want to avoid file I/O in tests, or are working with generated input content.\n\nArguments\n\ncontent::AbstractString: ABAQUS input file content as a string\n\nReturns\n\nAn AbaqusReader.Model object (same structure as abaqus_read_model)\n\nExamples\n\ninp_content = \"\"\"\n*HEADING\nTest model\n*NODE\n1, 0.0, 0.0, 0.0\n*ELEMENT, TYPE=C3D8\n1, 1, 2, 3, 4, 5, 6, 7, 8\n*MATERIAL, NAME=STEEL\n*ELASTIC\n210000.0, 0.3\n\"\"\"\n\nmodel = abaqus_parse_model(inp_content)\nprintln(\"Materials: \", keys(model.materials))\n\nSee Also\n\nabaqus_read_model: Read model from file\nabaqus_parse_mesh: Parse only mesh from string\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.register_element!","page":"API Reference","title":"AbaqusReader.register_element!","text":"register_element!(element_name::String, num_nodes::Int, element_type::String)\n\nRegister a new element type dynamically without modifying the TOML database. Useful for handling element variations not yet in the database.\n\nArguments\n\nelement_name: ABAQUS element name (e.g., \"C3D10I\", \"C3D8RT\")\nnum_nodes: Number of nodes in the element\nelement_type: Topology type (e.g., \"Tet10\", \"Hex8\", \"Tri3\", \"Quad4\")\n\nExample\n\n# Register a C3D10I element (10-node incompatible mode tet)\nregister_element!(\"C3D10I\", 10, \"Tet10\")\n\n# Now you can read meshes containing C3D10I elements\nmesh = abaqus_read_mesh(\"model_with_c3d10i.inp\")\n\nTo make the element permanently available, consider adding it to  data/abaqus_elements.toml and submitting a pull request.\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.create_surface_elements","page":"API Reference","title":"AbaqusReader.create_surface_elements","text":"create_surface_elements(mesh::Dict, surface_name::String) -> Vector{Tuple{Symbol, Vector{Int}}}\n\nCreate explicit surface elements from an implicit surface definition in an ABAQUS mesh.\n\nABAQUS surfaces are typically defined implicitly as (element, face) pairs. This function converts those implicit definitions into explicit surface elements with their own connectivity, which is useful for applying boundary conditions, extracting surface nodes, or visualization.\n\nArguments\n\nmesh::Dict: Mesh dictionary as returned by abaqus_read_mesh\nsurface_name::String: Name of the surface to extract (must exist in mesh[\"surface_sets\"])\n\nReturns\n\nVector{Tuple{Symbol, Vector{Int}}} where each tuple contains:\n\nElement type symbol (e.g., :Tri3, :Quad4) for the surface element\nNode connectivity vector for that surface element\n\nExamples\n\nusing AbaqusReader\n\n# Read mesh with surface definitions\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Check available surfaces\nprintln(\"Available surfaces: \", keys(mesh[\"surface_sets\"]))\n\n# Create surface elements for a named surface\nsurface_elems = create_surface_elements(mesh, \"LOAD_SURFACE\")\n\n# Extract unique nodes on the surface\nsurface_nodes = Set{Int}()\nfor (elem_type, connectivity) in surface_elems\n    union!(surface_nodes, connectivity)\nend\nprintln(\"Surface has $(length(surface_nodes)) unique nodes\")\n\n# Get coordinates of surface nodes\nsurface_coords = [mesh[\"nodes\"][nid] for nid in surface_nodes]\n\n# Apply boundary conditions to surface nodes\nfor node_id in surface_nodes\n    # Apply BC at node_id...\nend\n\nSurface Element Types\n\nDepending on the parent volume element type and face, surface elements can be:\n\n:Tri3 - 3-node triangle (from tet faces, wedge faces)\n:Tri6 - 6-node triangle (from quadratic tet faces)\n:Quad4 - 4-node quadrilateral (from hex faces, wedge faces)\n:Quad8 - 8-node quadrilateral (from quadratic hex faces)\n\nSee Also\n\nabaqus_read_mesh: Read mesh data containing surface definitions\nabaqus_read_model: Read complete model with surfaces\n\nNotes\n\nSurface must exist in mesh[\"surface_sets\"] or an error will be thrown\nThe parent elements referenced in the surface definition must exist in the mesh\nEach (element, face) pair generates one surface element\nUseful for extracting boundary nodes for applying loads or boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"api/#AbaqusReader.abaqus_download","page":"API Reference","title":"AbaqusReader.abaqus_download","text":"abaqus_download(model_name, env=ENV; dryrun=false) -> String\n\nDownload an ABAQUS example model from a remote repository.\n\nThis utility function downloads example ABAQUS input files for testing and learning purposes. It requires environment variables to be set for specifying the download URL and destination.\n\nArguments\n\nmodel_name: Name of the model file to download (e.g., \"piston_ring_2d.inp\")\nenv: Environment dictionary (defaults to ENV)\ndryrun::Bool: If true, skip actual download (for testing)\n\nReturns\n\nString: Full path to the downloaded file\nReturns path immediately if file already exists locally\n\nRequired Environment Variables\n\nABAQUS_DOWNLOAD_URL: Base URL for downloading models\nExample: \"https://example.com/models\"\nThe model file will be fetched from $ABAQUS_DOWNLOAD_URL/$model_name\n\nOptional Environment Variables\n\nABAQUS_DOWNLOAD_DIR: Directory where files will be saved\nDefaults to current directory if not set\nWill create directory if it doesn't exist\n\nExamples\n\nusing AbaqusReader\n\n# Set up environment variables\nENV[\"ABAQUS_DOWNLOAD_URL\"] = \"https://example.com/abaqus/models\"\nENV[\"ABAQUS_DOWNLOAD_DIR\"] = \"/path/to/models\"\n\n# Download a model\nfilepath = abaqus_download(\"piston_ring_2d.inp\")\n\n# Use the downloaded file\nmesh = abaqus_read_mesh(filepath)\n\nErrors\n\nThrows an error if:\n\nABAQUS_DOWNLOAD_URL is not set and file doesn't exist locally\nDownload fails (network error, file not found, etc.)\n\nNotes\n\nFiles are only downloaded once; subsequent calls return the existing file path\nUseful for testing, tutorials, and reproducible examples\nCheck the AbaqusReader repository for available example models\n\n\n\n\n\n","category":"function"},{"location":"elements/#Supported-Elements","page":"Supported Elements","title":"Supported Elements","text":"AbaqusReader.jl supports 60+ ABAQUS element types across multiple categories. Element variants (e.g., C3D8R, C3D8H) with the same node count map to the same generic element type, as the package focuses on mesh topology rather than analysis-specific details like integration schemes.","category":"section"},{"location":"elements/#3D-Solid-Elements","page":"Supported Elements","title":"3D Solid Elements","text":"","category":"section"},{"location":"elements/#Tetrahedral-Elements","page":"Supported Elements","title":"Tetrahedral Elements","text":"ABAQUS Element Nodes Generic Type Description\nC3D4 4 :Tet4 4-node linear tetrahedron. Should be avoided except as filler in low-stress regions - exhibits slow convergence and is overly stiff.\nC3D4H 4 :Tet4 4-node linear tetrahedron, hybrid formulation for nearly incompressible materials. Use only as filler element.\nC3D10 10 :Tet10 10-node quadratic tetrahedron. Recommended for tetrahedral meshes - suitable for general usage, good for complex geometries.\nC3D10H 10 :Tet10 10-node quadratic tetrahedron, hybrid formulation for nearly incompressible materials. More expensive than nonhybrid.\nC3D10M 10 :Tet10 10-node modified tetrahedron. Excellent choice - minimal locking, works well in contact and large deformation.\nC3D10R 10 :Tet10 10-node quadratic tetrahedron, reduced integration. May develop volumetric locking with nearly incompressible materials.","category":"section"},{"location":"elements/#Wedge/Prism-Elements","page":"Supported Elements","title":"Wedge/Prism Elements","text":"ABAQUS Element Nodes Generic Type Description\nC3D6 6 :Wedge6 6-node linear triangular prism. Use only when necessary to complete a mesh, far from critical areas. Requires fine meshing.\nC3D15 15 :Wedge15 15-node quadratic triangular prism. Better accuracy than C3D6, good for transitioning between mesh densities.","category":"section"},{"location":"elements/#Hexahedral-(Brick)-Elements","page":"Supported Elements","title":"Hexahedral (Brick) Elements","text":"ABAQUS Element Nodes Generic Type Description\nC3D8 8 :Hex8 8-node linear brick with full integration. Does not lock with nearly incompressible materials. May suffer from shear locking in bending.\nC3D8H 8 :Hex8 8-node linear brick, hybrid formulation. For incompressible or nearly incompressible materials.\nC3D8I 8 :Hex8 8-node brick with incompatible modes. Enhanced for bending - eliminates parasitic shear. Best with rectangular element shapes.\nC3D8R 8 :Hex8 8-node brick, reduced integration with hourglass control. Very popular - significantly reduces running time. Use with reasonably fine meshes.\nC3D8RH 8 :Hex8 8-node brick, reduced integration and hybrid. Combines benefits of reduced integration with pressure interpolation.\nC3D20 20 :Hex20 20-node quadratic brick, full integration (27 points). Higher accuracy for smooth problems, captures stress concentrations well.\nC3D20E 20 :Hex20 20-node quadratic brick, enhanced strain formulation. Improved behavior for some applications.\nC3D20H 20 :Hex20 20-node quadratic brick, hybrid. For nearly incompressible materials to avoid volumetric locking.\nC3D20R 20 :Hex20 20-node brick, reduced integration (8 points). Recommended over C3D20 - generally more accurate and ~3.5Ã— faster.\nC3D20RH 20 :Hex20 20-node brick, reduced integration and hybrid. Efficient with hybrid formulation for nearly incompressible materials.","category":"section"},{"location":"elements/#Cohesive-Elements","page":"Supported Elements","title":"Cohesive Elements","text":"ABAQUS Element Nodes Generic Type Description\nCOH3D8 8 :Hex8 8-node 3D cohesive element for modeling adhesive joints, gaskets, and delamination.","category":"section"},{"location":"elements/#Shell-Elements","page":"Supported Elements","title":"Shell Elements","text":"","category":"section"},{"location":"elements/#Triangular-Shells","page":"Supported Elements","title":"Triangular Shells","text":"ABAQUS Element Nodes Generic Type Description\nS3 3 :Tri3 3-node triangular general-purpose shell, full integration. Use second-order triangular shells when possible.\nS3R 3 :Tri3 3-node triangular shell, reduced integration. Faster than S3, suitable for large models.\nSTRI3 3 :Tri3 3-node triangular shell element. Alternative triangular shell formulation.\nSTRI65 6 :Tri6 6-node triangular shell. More accurate than 3-node shells, quadratic interpolation captures stress concentrations better.","category":"section"},{"location":"elements/#Quadrilateral-Shells","page":"Supported Elements","title":"Quadrilateral Shells","text":"ABAQUS Element Nodes Generic Type Description\nS4 4 :Quad4 4-node quadrilateral shell, full integration. General-purpose for thin and thick shells.\nS4R 4 :Quad4 4-node quadrilateral shell, reduced integration with hourglass control. Recommended for most shell applications - good balance of accuracy and efficiency.\nS8R 8 :Quad8 8-node quadrilateral shell, reduced integration. Very accurate for smooth problems, better for geometric features and stress concentrations.","category":"section"},{"location":"elements/#2D-Continuum-Elements","page":"Supported Elements","title":"2D Continuum Elements","text":"","category":"section"},{"location":"elements/#Plane-Stress-(CPS)","page":"Supported Elements","title":"Plane Stress (CPS)","text":"For structures where stress in one direction is negligible (thin plates loaded in their plane).\n\nABAQUS Element Nodes Generic Type Description\nCPS3 3 :CPS3 3-node linear plane stress triangle. Avoid except as filler - constant stress element, very fine mesh needed. Use CPS6 or quads.\nCPS4 4 :Quad4 4-node bilinear plane stress quadrilateral, full integration. Does not lock for nearly incompressible materials.\nCPS4R 4 :Quad4 4-node plane stress quad, reduced integration with hourglass control. Recommended for most plane stress analyses - computationally efficient.\nCPS4I 4 :Quad4 4-node plane stress quad with incompatible modes. Enhanced for bending. Best with rectangular element shapes.\nCPS6 6 :Tri6 6-node modified plane stress triangle. Better than CPS3 for triangular meshes, minimal locking.\nCPS8 8 :Quad8 8-node quadratic plane stress quad, full integration. Higher accuracy for smooth problems.\nCPS8R 8 :Quad8 8-node plane stress quad, reduced integration. Generally more accurate than CPS8 and significantly faster.","category":"section"},{"location":"elements/#Plane-Strain-(CPE)","page":"Supported Elements","title":"Plane Strain (CPE)","text":"For structures with no strain in one direction (long structures with uniform cross-section).\n\nABAQUS Element Nodes Generic Type Description\nCPE3 3 :Tri3 3-node linear plane strain triangle. Overly stiff, avoid except as filler in noncritical regions.\nCPE4 4 :Quad4 4-node bilinear plane strain quad, full integration. Selective reduced integration prevents volumetric locking.\nCPE4R 4 :Quad4 4-node plane strain quad, reduced integration with hourglass control. Widely used - computationally efficient, requires reasonably fine mesh.\nCPE4I 4 :Quad4 4-node plane strain quad with incompatible modes. Eliminates parasitic shear in bending. Best with rectangular shapes.\nCPE6 6 :Tri6 6-node modified plane strain triangle. Improved over linear triangles, minimal locking, robust in finite deformation.\nCPE8 8 :Quad8 8-node quadratic plane strain quad, full integration. Higher accuracy for smooth problems and curved boundaries.\nCPE8R 8 :Quad8 8-node plane strain quad, reduced integration. Recommended for second-order plane strain analysis - more accurate and efficient than CPE8.","category":"section"},{"location":"elements/#Axisymmetric-(CAX)","page":"Supported Elements","title":"Axisymmetric (CAX)","text":"For rotationally symmetric structures and loading.\n\nABAQUS Element Nodes Generic Type Description\nCAX3 3 :Tri3 3-node linear axisymmetric triangle. Should be avoided - constant stress element with slow convergence. Use CAX6 or quads.\nCAX4 4 :Quad4 4-node bilinear axisymmetric quad, full integration. Selective reduced integration prevents locking with incompressible materials.\nCAX4R 4 :Quad4 4-node axisymmetric quad, reduced integration with hourglass control. Most commonly used axisymmetric element - good balance of accuracy and efficiency.\nCAX4I 4 :Quad4 4-node axisymmetric quad with incompatible modes. Enhanced bending behavior, eliminates parasitic shear stresses.\nCAX6 6 :Tri6 6-node modified axisymmetric triangle. Improved over first-order triangles, minimal locking, works well in contact.\nCAX8 8 :Quad8 8-node quadratic axisymmetric quad, full integration. Higher accuracy for smooth problems and curved geometries.\nCAX8R 8 :Quad8 8-node axisymmetric quad, reduced integration. Recommended for second-order axisymmetric analysis - more accurate and efficient.","category":"section"},{"location":"elements/#Beam-and-Truss-Elements","page":"Supported Elements","title":"Beam and Truss Elements","text":"ABAQUS Element Nodes Generic Type Description\nT2D2 2 :Seg2 2-node linear 2D truss element. Models pin-jointed structures with only axial loads (no bending).\nT3D2 2 :Seg2 2-node linear 3D truss element. For spatial structures carrying only axial loads. Common in space frames and towers.\nB31 2 :Seg2 2-node linear beam in space. Timoshenko beam theory includes transverse shear deformation. Use when shear is important.\nB32 3 :Seg3 3-node quadratic beam in space. Timoshenko beam theory. Quadratic interpolation for curved beams and improved bending accuracy.\nB33 2 :Seg2 2-node linear beam with cubic interpolation. Euler-Bernoulli beam theory (no shear). Better for slender beams.","category":"section"},{"location":"elements/#Element-Suffix-Meanings","page":"Supported Elements","title":"Element Suffix Meanings","text":"Understanding the suffix letters helps in selecting the right element:\n\nR = Reduced integration - Fewer integration points, faster computation, may need finer mesh to avoid hourglassing in first-order elements\nH = Hybrid formulation - Independent pressure interpolation for nearly incompressible or fully incompressible materials\nI = Incompatible modes - Enhanced for better bending behavior, eliminates parasitic shear stresses\nM = Modified formulation - Improved performance with minimal locking, works well in contact problems\nE = Enhanced strain - Improved formulation for certain applications","category":"section"},{"location":"elements/#Quick-Selection-Guide","page":"Supported Elements","title":"Quick Selection Guide","text":"Need accuracy with coarse mesh? Use second-order elements (10, 15, 20, 8 nodes)\nNeed computational efficiency? Use reduced integration (R suffix) with adequate mesh density\nNearly incompressible material? Use hybrid elements (H suffix)\nBending-dominated problem? Consider incompatible modes (I suffix) or second-order elements\nContact analysis? Consider modified elements (M suffix, e.g., C3D10M)\nAvoid first-order triangles and tets (C3D4, CPS3, CPE3, CAX3) except as filler elements","category":"section"},{"location":"elements/#Adding-New-Element-Types","page":"Supported Elements","title":"Adding New Element Types","text":"Adding support for new ABAQUS element types is straightforward - element definitions are stored in a TOML database file rather than in code. See the Contributing Guide for detailed instructions.","category":"section"},{"location":"elements/#Handling-Unknown-Element-Types","page":"Supported Elements","title":"Handling Unknown Element Types","text":"If you encounter an ABAQUS element type that is not yet in the database, AbaqusReader will provide a clear error message with instructions on how to proceed.","category":"section"},{"location":"elements/#Dynamic-Registration-(Quick-Fix)","page":"Supported Elements","title":"Dynamic Registration (Quick Fix)","text":"For immediate use, you can register an element type dynamically before reading your mesh:\n\nusing AbaqusReader\n\n# Register a C3D10I element (10-node incompatible mode tetrahedron)\nregister_element!(\"C3D10I\", 10, \"Tet10\")\n\n# Now you can read meshes containing C3D10I elements\nmesh = abaqus_read_mesh(\"model_with_c3d10i.inp\")\n\nThe register_element! function takes three arguments:\n\nelement_name: The ABAQUS element name (case-insensitive, will be uppercased)\nnum_nodes: Number of nodes in the element\nelement_type: The generic topology type (e.g., \"Tet4\", \"Hex8\", \"Tri3\", \"Quad4\", \"Seg2\")\n\nThis is useful when:\n\nYou need to quickly process a file with an uncommon element variant\nYou're testing or prototyping\nYou don't want to modify the package source","category":"section"},{"location":"elements/#Permanent-Addition-(Recommended)","page":"Supported Elements","title":"Permanent Addition (Recommended)","text":"For element types that should be permanently available:\n\nEdit data/abaqus_elements.toml in the AbaqusReader.jl repository\nAdd a new section following the existing format:\n[ELEMENT_NAME]\nnodes = <number_of_nodes>\ntype = \"<topology_type>\"\ndescription = \"Element description from ABAQUS documentation\"\nRun tests to verify: julia --project=. test/runtests.jl\nSubmit a pull request to https://github.com/ahojukka5/AbaqusReader.jl\n\nSee Issue #67 for the discussion that led to this feature.","category":"section"},{"location":"elements/#Common-Element-Variations","page":"Supported Elements","title":"Common Element Variations","text":"ABAQUS uses many variations of standard elements with the same node layout but different analysis characteristics:\n\nIntegration variations: C3D8 vs C3D8R (full vs reduced integration)\nMaterial model variations: C3D8 vs C3D8H (standard vs hybrid for incompressible materials)\nFormulation variations: C3D8 vs C3D8I (standard vs incompatible modes)\nPhysics variations: CPS4 vs CPE4 (plane stress vs plane strain)\n\nSince AbaqusReader focuses on mesh topology rather than analysis formulations, these variations with the same node count map to the same generic element type. The specific ABAQUS element name is preserved in the parsed data for reference.","category":"section"},{"location":"contributing/#Contributing-to-AbaqusReader.jl","page":"Contributing","title":"Contributing to AbaqusReader.jl","text":"Thank you for your interest in contributing! This guide will help you add new element types, report issues, and improve the package.","category":"section"},{"location":"contributing/#Adding-New-ABAQUS-Element-Types","page":"Contributing","title":"Adding New ABAQUS Element Types","text":"AbaqusReader.jl uses an external TOML database for element definitions, making it easy to add new elements without modifying Julia code.","category":"section"},{"location":"contributing/#Step-by-Step-Guide","page":"Contributing","title":"Step-by-Step Guide","text":"","category":"section"},{"location":"contributing/#1.-Find-Element-Information","page":"Contributing","title":"1. Find Element Information","text":"Look up the element in the ABAQUS Analysis User's Guide to determine:\n\nElement name (e.g., C3D8R, S4R, CPE4)\nNumber of nodes (e.g., 8, 4, 4)\nElement topology (tetrahedral, hexahedral, shell, etc.)","category":"section"},{"location":"contributing/#2.-Edit-the-Element-Database","page":"Contributing","title":"2. Edit the Element Database","text":"Open data/abaqus_elements.toml and add a new section in the appropriate category:\n\n[YOUR_ELEMENT_NAME]\nnodes = <number>\ntype = \"<GenericType>\"\ndescription = \"<element description from ABAQUS manual>\"\n\nExample - Adding a new shell element:\n\n[S8R5]\nnodes = 8\ntype = \"Quad8\"\ndescription = \"8-node quadrilateral shell, reduced integration, 5 DOF per node\"","category":"section"},{"location":"contributing/#3.-Choose-the-Correct-Generic-Type","page":"Contributing","title":"3. Choose the Correct Generic Type","text":"Map your ABAQUS element to one of these generic types based on topology:\n\n3D Solid Elements:\n\n\"Tet4\" - 4-node tetrahedron\n\"Tet10\" - 10-node tetrahedron\n\"Wedge6\" - 6-node triangular prism\n\"Wedge15\" - 15-node triangular prism\n\"Hex8\" - 8-node hexahedron\n\"Hex20\" - 20-node hexahedron\n\"Hex27\" - 27-node hexahedron (if needed)\n\nShell Elements:\n\n\"Tri3\" - 3-node triangle\n\"Tri6\" - 6-node triangle\n\"Quad4\" - 4-node quadrilateral\n\"Quad8\" - 8-node quadrilateral\n\"Quad9\" - 9-node quadrilateral (if needed)\n\n2D Continuum:\n\n\"Tri3\" - 3-node triangle\n\"Tri6\" - 6-node triangle\n\"Quad4\" - 4-node quadrilateral\n\"Quad8\" - 8-node quadrilateral\n\nBeam/Truss:\n\n\"Seg2\" - 2-node line\n\"Seg3\" - 3-node line\n\nNote: Elements with the same node count and topology map to the same generic type. For example, C3D8, C3D8R, C3D8H, and C3D8I all map to \"Hex8\" since they're all 8-node hexahedra. Similarly, CPS3 (plane stress), CPE3 (plane strain), and CAX3 (axisymmetric) all map to \"Tri3\" since they're all 3-node triangles. AbaqusReader focuses on mesh topology, not analysis formulation.","category":"section"},{"location":"contributing/#4.-Add-a-Test","page":"Contributing","title":"4. Add a Test","text":"Add a test to test/test_parse_mesh.jl to verify the new element works:\n\n@testset \"YOUR_ELEMENT\" begin\n    mesh_data = \"\"\"\n    *HEADING\n    Test\n    *NODE\n    1, 0.0, 0.0, 0.0\n    2, 1.0, 0.0, 0.0\n    # ... more nodes\n    *ELEMENT, TYPE=YOUR_ELEMENT\n    1, 1, 2, 3, 4, 5, 6, 7, 8\n    \"\"\"\n    \n    mesh = abaqus_read_mesh(mesh_data, \"YOUR_ELEMENT_test\")\n    \n    @test haskey(mesh, \"elements\")\n    @test haskey(mesh, \"element_types\")\n    @test mesh[\"element_types\"][1] == :ExpectedGenericType\n    @test length(mesh[\"elements\"][1]) == EXPECTED_NODE_COUNT\nend","category":"section"},{"location":"contributing/#5.-Test-Your-Changes","page":"Contributing","title":"5. Test Your Changes","text":"Run the test suite to ensure everything works:\n\njulia --project=. -e 'using Pkg; Pkg.test()'","category":"section"},{"location":"contributing/#6.-Submit-a-Pull-Request","page":"Contributing","title":"6. Submit a Pull Request","text":"Fork the repository on GitHub\nCreate a branch for your changes: git checkout -b add-element-YOUR_ELEMENT\nCommit your changes: git commit -am \"Add support for YOUR_ELEMENT element\"\nPush to your fork: git push origin add-element-YOUR_ELEMENT\nOpen a Pull Request on GitHub","category":"section"},{"location":"contributing/#Element-Database-File-Structure","page":"Contributing","title":"Element Database File Structure","text":"The database is organized into categories for easier maintenance:\n\n# =============================================================================\n# 3D SOLID ELEMENTS - TETRAHEDRAL\n# =============================================================================\n\n[C3D4]\nnodes = 4\ntype = \"Tet4\"\ndescription = \"4-node linear tetrahedron...\"\n\n# =============================================================================\n# SHELL ELEMENTS - QUADRILATERAL\n# =============================================================================\n\n[S4R]\nnodes = 4\ntype = \"Quad4\"\ndescription = \"4-node quadrilateral shell...\"\n\nAdd your element in the appropriate category, or create a new category if needed.","category":"section"},{"location":"contributing/#Understanding-Element-Suffixes","page":"Contributing","title":"Understanding Element Suffixes","text":"ABAQUS uses suffixes to indicate formulation variants:\n\nR = Reduced integration (fewer integration points)\nH = Hybrid formulation (for nearly incompressible materials)\nI = Incompatible modes (enhanced bending behavior)\nM = Modified formulation (reduced locking)\nE = Enhanced strain formulation\n\nExample: C3D8, C3D8R, C3D8H, C3D8I, C3D8RH all have 8 nodes â†’ map to \"Hex8\"","category":"section"},{"location":"contributing/#Reporting-Issues","page":"Contributing","title":"Reporting Issues","text":"When reporting issues, please include:\n\nJulia version: versioninfo()\nPackage version: ] status AbaqusReader\nMinimal example: Simplest code that reproduces the issue\nInput file: If possible, share the .inp file (or a minimal excerpt)\nError message: Complete error message and stack trace","category":"section"},{"location":"contributing/#Good-Issue-Report-Example","page":"Contributing","title":"Good Issue Report Example","text":"**Description:** Parser fails on NGEN keyword\n\n**Environment:**\n- Julia 1.9.3\n- AbaqusReader v0.2.6\n\n**Minimal example:**\nusing AbaqusReader\nmesh = abaqus_read_mesh(\"test.inp\")\n\n**Error:**\nERROR: KeyError: key :NGEN not found\n...stack trace...\n\n**Input file excerpt:**\n*HEADING\nTest\n*NODE\n1, 0.0, 0.0, 0.0\n*NGEN\n...","category":"section"},{"location":"contributing/#Development-Workflow","page":"Contributing","title":"Development Workflow","text":"","category":"section"},{"location":"contributing/#Setting-Up-Development-Environment","page":"Contributing","title":"Setting Up Development Environment","text":"# Clone the repository\ngit clone https://github.com/JuliaFEM/AbaqusReader.jl.git\ncd AbaqusReader.jl\n\n# Activate the project environment\njulia --project=.\n\n# Install dependencies\nusing Pkg\nPkg.instantiate()\n\n# Run tests\nPkg.test()","category":"section"},{"location":"contributing/#Code-Style","page":"Contributing","title":"Code Style","text":"Follow standard Julia style conventions\nKeep functions focused (single responsibility)\nAdd docstrings to public functions\nPrefer simple, readable code over clever code\nUse descriptive variable names","category":"section"},{"location":"contributing/#Testing","page":"Contributing","title":"Testing","text":"Add tests for new functionality\nEnsure all tests pass before submitting PR\nTest coverage should not decrease","category":"section"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"Update documentation for user-facing changes\nAdd examples for new features\nKeep API documentation up to date","category":"section"},{"location":"contributing/#Package-Philosophy","page":"Contributing","title":"Package Philosophy","text":"AbaqusReader.jl is designed around two distinct use cases:","category":"section"},{"location":"contributing/#1.-Mesh-Only-Parsing-(abaqus_read_mesh)","page":"Contributing","title":"1. Mesh-Only Parsing (abaqus_read_mesh)","text":"Extract only geometry and topology\nReturns simple Dict structure\nFast and lightweight\nNo physics, materials, or boundary conditions","category":"section"},{"location":"contributing/#2.-Complete-Model-Parsing-(abaqus_read_model)","page":"Contributing","title":"2. Complete Model Parsing (abaqus_read_model)","text":"Extract the complete simulation recipe\nReturns structured Model object\nEverything needed to reproduce the simulation\n\nKeep these two paths distinct! Don't conflate mesh parsing with model parsing.","category":"section"},{"location":"contributing/#Design-Principles","page":"Contributing","title":"Design Principles","text":"When contributing, keep these principles in mind:\n\nSimplicity over cleverness - This is a parser, not a performance-critical solver\nClear function names - Prefer explicit over generic names\nBackward compatibility - Public API must remain stable\nModern Julia - Use Julia 1.0+ idioms (no deprecated features)\nDirect dispatch - Prefer clear function calls over complex Val-based dispatch\nExternal data - Element definitions in TOML, not hardcoded in Julia","category":"section"},{"location":"contributing/#Questions?","page":"Contributing","title":"Questions?","text":"Issues: Open an issue on GitHub\nDiscussions: Use GitHub Discussions for questions and ideas\nEmail: Contact the maintainers for sensitive issues\n\nThank you for contributing to AbaqusReader.jl! ðŸŽ‰","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page demonstrates the two main ways to use AbaqusReader.jl.","category":"section"},{"location":"examples/#Example-1:-Reading-Just-the-Mesh","page":"Examples","title":"Example 1: Reading Just the Mesh","text":"The simplest use case - extract only geometry and topology for visualization or conversion:\n\nusing AbaqusReader\n\n# Read mesh data from an ABAQUS input file\nmesh = abaqus_read_mesh(\"my_model.inp\")\n\n# mesh is a Dict with the following keys:\n# - \"nodes\": Dict mapping node IDs to coordinates [x, y, z]\n# - \"elements\": Dict mapping element IDs to connectivity arrays\n# - \"element_types\": Dict mapping element IDs to element type symbols (topology)\n# - \"element_codes\": Dict mapping element IDs to original ABAQUS element names\n# - \"node_sets\": Dict mapping set names to arrays of node IDs\n# - \"element_sets\": Dict mapping set names to arrays of element IDs\n# - \"surface_sets\": Dict mapping surface names to arrays of (element_id, face_symbol) tuples\n# - \"surface_types\": Dict mapping surface names to surface type (e.g., :ELEMENT)\n\n# Access node coordinates\nnode_1_coords = mesh[\"nodes\"][1]  # [x, y, z]\n\n# Access all nodes in a node set\nsym_nodes = mesh[\"node_sets\"][\"SYMMETRY\"]\n\n# Access elements in an element set\nvolume_elements = mesh[\"element_sets\"][\"PART1\"]\n\n# Get element connectivity\nelement_1_nodes = mesh[\"elements\"][1]  # Array of node IDs\n\n# Get element type (topological type, e.g., Tri3, Quad4, Tet4, Hex8)\nelement_1_type = mesh[\"element_types\"][1]  # e.g., :Tet4, :Hex8\n\n# Get original ABAQUS element code (e.g., CPS3, CPE3, C3D8R)\nelement_1_code = mesh[\"element_codes\"][1]  # e.g., :CPS3, :C3D8R\n\n# Use element codes to determine physics formulation if needed\nif mesh[\"element_codes\"][1] == :CPS3\n    println(\"Element 1 is plane stress\")\nelseif mesh[\"element_codes\"][1] == :CPE3\n    println(\"Element 1 is plane strain\")\nelseif mesh[\"element_codes\"][1] == :CAX3\n    println(\"Element 1 is axisymmetric\")\nend","category":"section"},{"location":"examples/#Use-Cases-for-Mesh-Only-Parsing","page":"Examples","title":"Use Cases for Mesh-Only Parsing","text":"Mesh visualization: Extract geometry for plotting with Makie.jl, Plots.jl, or external tools\nFormat conversion: Convert ABAQUS meshes to other FEM formats\nCustom FEM: Build your own finite element implementation on ABAQUS geometries\nMesh inspection: Quickly check mesh quality, element counts, node sets","category":"section"},{"location":"examples/#Example-2:-Reading-the-Complete-Model","page":"Examples","title":"Example 2: Reading the Complete Model","text":"When you need to reproduce the entire simulation, not just the geometry:\n\nusing AbaqusReader\n\n# Read the complete model definition\nmodel = abaqus_read_model(\"simulation.inp\")\n\n# model is an AbaqusReader.Model instance with fields:\n# - mesh: Dict (same as returned by abaqus_read_mesh)\n# - materials: Dict mapping material names to Material structs\n# - properties: Dict of section properties\n# - boundary_conditions: Array of BoundaryCondition structs\n# - steps: Array of Step structs defining the analysis sequence\n\n# Access the mesh (same as mesh-only parsing)\nnodes = model.mesh[\"nodes\"]\nelements = model.mesh[\"elements\"]\n\n# Access material definitions\nsteel = model.materials[\"STEEL\"]\n# Materials contain properties like:\n# - elastic: Young's modulus, Poisson's ratio\n# - density: Material density\n# - plastic: Yield stress, plastic strain curves\n\n# Access boundary conditions\nfor bc in model.boundary_conditions\n    println(\"BC on set: $(bc.set_name)\")\n    println(\"  DOF: $(bc.dof)\")\n    println(\"  Value: $(bc.value)\")\nend\n\n# Access analysis steps\nfor step in model.steps\n    println(\"Step: $(step.name)\")\n    println(\"  Type: $(step.type)\")\n    # Steps contain loads, BCs, and output requests specific to that step\nend","category":"section"},{"location":"examples/#Use-Cases-for-Complete-Model-Parsing","page":"Examples","title":"Use Cases for Complete Model Parsing","text":"Simulation reproduction: Extract all parameters to reproduce analysis in another solver\nModel verification: Programmatically check material properties, BCs, and loads\nParameter studies: Extract and modify simulation parameters for batch studies\nDocumentation: Auto-generate simulation documentation from .inp files\nSolver development: Use complete ABAQUS models as test cases for custom solvers","category":"section"},{"location":"examples/#Example-3:-Extracting-Surface-Elements","page":"Examples","title":"Example 3: Extracting Surface Elements","text":"Create explicit surface elements from volume element faces:\n\nusing AbaqusReader\n\n# Read mesh\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Create surface elements for a named surface\n# This converts implicit surface definitions (element + face)\n# into explicit surface element connectivity\nsurface_elements = create_surface_elements(mesh, \"LOAD_SURFACE\")\n\n# Returns Dict with:\n# - element IDs as keys\n# - node connectivity arrays as values\n# Surface elements are numbered starting from max(element_ids) + 1\n\n# Example: Apply loads to surface nodes\nsurface_nodes = Set()\nfor (elem_id, connectivity) in surface_elements\n    union!(surface_nodes, connectivity)\nend\nprintln(\"Surface has $(length(surface_nodes)) unique nodes\")","category":"section"},{"location":"examples/#Example-4:-Downloading-Test-Models","page":"Examples","title":"Example 4: Downloading Test Models","text":"AbaqusReader includes a helper to download example ABAQUS models:\n\nusing AbaqusReader\n\n# Download an example model (downloads to current directory)\nfilename = abaqus_download(\"piston_ring_2d\")\n\n# Then read it\nmesh = abaqus_read_mesh(filename)\n\n# The file is now available locally for further analysis\nprintln(\"Downloaded: $filename\")\nprintln(\"Nodes: \", length(mesh[\"nodes\"]))\nprintln(\"Elements: \", length(mesh[\"elements\"]))\n\nThis is useful for:\n\nTesting your analysis pipeline\nLearning the package with real models\nBenchmarking performance\nCreating reproducible examples","category":"section"},{"location":"examples/#Example-5:-Mesh-Statistics-and-Quality-Checks","page":"Examples","title":"Example 5: Mesh Statistics and Quality Checks","text":"Extract useful information about your mesh:\n\nusing AbaqusReader\nusing Statistics\n\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Count elements by type\nelement_type_counts = Dict{Symbol, Int}()\nfor elem_type in values(mesh[\"element_types\"])\n    element_type_counts[elem_type] = get(element_type_counts, elem_type, 0) + 1\nend\n\nprintln(\"Element type distribution:\")\nfor (etype, count) in element_type_counts\n    println(\"  $etype: $count elements\")\nend\n\n# Node set statistics\nprintln(\"\\nNode sets:\")\nfor (set_name, node_ids) in mesh[\"node_sets\"]\n    println(\"  $set_name: $(length(node_ids)) nodes\")\nend\n\n# Element set statistics  \nprintln(\"\\nElement sets:\")\nfor (set_name, elem_ids) in mesh[\"element_sets\"]\n    println(\"  $set_name: $(length(elem_ids)) elements\")\nend\n\n# Calculate bounding box\nall_coords = collect(values(mesh[\"nodes\"]))\nx_coords = [c[1] for c in all_coords]\ny_coords = [c[2] for c in all_coords]\nz_coords = [c[3] for c in all_coords]\n\nprintln(\"\\nBounding box:\")\nprintln(\"  X: [$(minimum(x_coords)), $(maximum(x_coords))]\")\nprintln(\"  Y: [$(minimum(y_coords)), $(maximum(y_coords))]\")\nprintln(\"  Z: [$(minimum(z_coords)), $(maximum(z_coords))]\")","category":"section"},{"location":"examples/#Example-6:-Converting-to-Other-Formats","page":"Examples","title":"Example 6: Converting to Other Formats","text":"Export mesh data to different formats for use in other tools:\n\nusing AbaqusReader\n\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Export to VTK format (pseudo-code - requires a VTK writer package)\n# using WriteVTK\n# vtk_grid(\"output\", mesh[\"nodes\"], mesh[\"elements\"])\n\n# Export nodes to CSV\nusing DelimitedFiles\n\n# Create node matrix [id, x, y, z]\nnode_matrix = zeros(length(mesh[\"nodes\"]), 4)\nfor (i, (node_id, coords)) in enumerate(sort(collect(mesh[\"nodes\"])))\n    node_matrix[i, :] = [node_id, coords...]\nend\n\nwritedlm(\"nodes.csv\", node_matrix, ',')\nprintln(\"Exported $(size(node_matrix, 1)) nodes to nodes.csv\")\n\n# Export element connectivity\nopen(\"elements.csv\", \"w\") do io\n    println(io, \"element_id,type,connectivity...\")\n    for (elem_id, connectivity) in sort(collect(mesh[\"elements\"]))\n        elem_type = mesh[\"element_types\"][elem_id]\n        println(io, \"$elem_id,$elem_type,$(join(connectivity, ','))\")\n    end\nend\nprintln(\"Exported $(length(mesh[\"elements\"])) elements to elements.csv\")","category":"section"},{"location":"examples/#Example-7:-Visualization-with-Makie.jl-(Conceptual)","page":"Examples","title":"Example 7: Visualization with Makie.jl (Conceptual)","text":"While AbaqusReader doesn't include visualization, the mesh data can be easily visualized:\n\nusing AbaqusReader\n# using GLMakie  # Uncomment if you have Makie installed\n\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Extract node coordinates as a matrix\nnode_ids = sort(collect(keys(mesh[\"nodes\"])))\ncoords = hcat([mesh[\"nodes\"][id] for id in node_ids]...)'\n\n# For shell or 2D meshes, plot nodes\n# scatter3d(coords[:, 1], coords[:, 2], coords[:, 3], markersize=5)\n\n# For volume meshes, extract surface elements first\n# surface_elems = create_surface_elements(mesh, \"OUTER_SURFACE\")\n# Then use a mesh plotting function\n\n# Alternatively, export to VTK and use ParaView for visualization\n\nTip: For serious visualization, consider exporting to VTK format and using ParaView, or use Julia packages like Makie.jl or PlotlyJS.jl for interactive 3D plots.","category":"section"},{"location":"examples/#Example-8:-Working-with-Surface-Definitions","page":"Examples","title":"Example 8: Working with Surface Definitions","text":"Extract and manipulate surface definitions for boundary conditions or loads:\n\nusing AbaqusReader\n\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Check what surfaces are defined\nprintln(\"Available surfaces:\")\nfor (surf_name, surf_def) in mesh[\"surface_sets\"]\n    println(\"  $surf_name: $(length(surf_def)) faces\")\n    println(\"    Type: $(mesh[\"surface_types\"][surf_name])\")\nend\n\n# Create explicit surface elements for a specific surface\nsurface_name = \"LOAD_SURFACE\"\nsurface_elements = create_surface_elements(mesh, surface_name)\n\nprintln(\"\\nSurface '$surface_name' details:\")\nprintln(\"  Number of surface elements: $(length(surface_elements))\")\n\n# Extract all unique nodes on the surface\nsurface_nodes = Set{Int}()\nfor (elem_id, connectivity) in surface_elements\n    union!(surface_nodes, connectivity)\nend\n\nprintln(\"  Number of surface nodes: $(length(surface_nodes))\")\nprintln(\"  Node IDs: $(sort(collect(surface_nodes)))\")\n\n# Get coordinates of surface nodes\nsurface_coords = [mesh[\"nodes\"][nid] for nid in sort(collect(surface_nodes))]\nprintln(\"  First surface node: $(surface_coords[1])\")\n\n# This surface node information can be used to:\n# - Apply pressure loads\n# - Define contact surfaces\n# - Extract results at specific locations\n# - Create visualizations of boundaries","category":"section"},{"location":"examples/#Working-with-Specific-Element-Types","page":"Examples","title":"Working with Specific Element Types","text":"The package automatically handles different ABAQUS element types:\n\nmesh = abaqus_read_mesh(\"mixed_elements.inp\")\n\n# Find all tetrahedral elements\ntet_elements = [id for (id, etype) in mesh[\"element_types\"] if etype == :Tet4]\n\n# Find all hexahedral elements  \nhex_elements = [id for (id, etype) in mesh[\"element_types\"] if etype == :Hex8]\n\n# Get connectivity for specific element type\nfor elem_id in tet_elements\n    nodes = mesh[\"elements\"][elem_id]\n    @assert length(nodes) == 4  # Tet4 has 4 nodes\nend","category":"section"},{"location":"examples/#Tips-and-Best-Practices","page":"Examples","title":"Tips and Best Practices","text":"","category":"section"},{"location":"examples/#Quiet-Operation","page":"Examples","title":"Quiet Operation","text":"By default, AbaqusReader operates quietly. If you need debug output for troubleshooting:\n\nusing Logging\n\nwith_logger(ConsoleLogger(stderr, Logging.Debug)) do\n    mesh = abaqus_read_mesh(\"model.inp\")\nend","category":"section"},{"location":"examples/#Large-Models","page":"Examples","title":"Large Models","text":"For large models, mesh-only parsing is significantly faster than complete model parsing:\n\n# Fast - only parses mesh sections\n@time mesh = abaqus_read_mesh(\"large_model.inp\")\n\n# Slower - parses everything\n@time model = abaqus_read_model(\"large_model.inp\")\n\nChoose the appropriate function for your needs to optimize performance.","category":"section"},{"location":"examples/#Flat-vs.-Structured-Input-Files","page":"Examples","title":"Flat vs. Structured Input Files","text":"The package works best with \"flat\" ABAQUS input files where all definitions are in a single file. Structured files with multiple parts and assemblies may require consolidation first.","category":"section"},{"location":"philosophy/#Philosophy:-ABAQUS-as-a-Warning-Example","page":"Philosophy","title":"Philosophy: ABAQUS as a Warning Example","text":"(Image: ABAQUS Design Philosophy - Separation of Concerns)","category":"section"},{"location":"philosophy/#Our-Position","page":"Philosophy","title":"Our Position","text":"ABAQUS element design is a cautionary tale in software engineering.\n\nFrom a computer science perspective, ABAQUS demonstrates what happens when you violate separation of concerns and mix orthogonal dimensions into a single type hierarchy. We're software engineers, and we recognize bad design when we see it - even in commercial products.\n\nWe don't dance to ABAQUS's whistle. We support their format (interoperability) but don't replicate their architectural mistakes (exponential hell).\n\n","category":"section"},{"location":"philosophy/#The-Problem:-Exponential-Complexity","page":"Philosophy","title":"The Problem: Exponential Complexity","text":"ABAQUS creates separate element types for every combination of:\n\nTopology (3 nodes, 4 nodes, 8 nodes...)\nPhysics (plane stress, plane strain, axisymmetric, 3D...)\nIntegration (full, reduced, selective...)\nFeatures (hybrid, incompatible modes, temperature...)","category":"section"},{"location":"philosophy/#Example:-The-Triangle-Family","page":"Philosophy","title":"Example: The Triangle Family","text":"CPS3  = 3 nodes + Plane Stress + Standard\nCPE3  = 3 nodes + Plane Strain + Standard\nCAX3  = 3 nodes + Axisymmetric + Standard\nC3D3  = 3 nodes + 3D + Standard\n...\n\nSame 3-node triangle topology, different physics. But ABAQUS treats them as completely different element types.\n\nResult: 100+ element types with massive code duplication.","category":"section"},{"location":"philosophy/#The-Growth-Pattern","page":"Philosophy","title":"The Growth Pattern","text":"Types = Topologies Ã— Physics Ã— Integration Ã— Features\n\nExample:\n  10 topologies Ã— 4 physics Ã— 3 integration Ã— 2 features = 240 types\n\nAdding one topology â†’ Create 24 new variants (4Ã—3Ã—2)\nAdding one physics â†’ Create 60 new variants (10Ã—3Ã—2)\n\nThis is O(exponential) complexity. Unmaintainable. Unextensible.\n\n","category":"section"},{"location":"philosophy/#Why-This-Is-Wrong:-SOLID-Principles-Violated","page":"Philosophy","title":"Why This Is Wrong: SOLID Principles Violated","text":"ABAQUS's element design is a textbook example of violating every SOLID principle from object-oriented design. Let's examine each violation:","category":"section"},{"location":"philosophy/#**S**-Single-Responsibility-Principle","page":"Philosophy","title":"S - Single Responsibility Principle âŒ","text":"Principle: \"A class should have one, and only one, reason to change.\"\n\nABAQUS Violation: Each element type has multiple responsibilities:\n\nTopology (geometric shape and connectivity)\nPhysics formulation (stress state, material behavior)\nIntegration scheme (quadrature rules)\nSpecial features (hybrid, incompatible modes)\n\n! CPS3 is responsible for ALL of these:\nSUBROUTINE CPS3_STIFFNESS(...)\n  ! Topology: 3-node triangle shape functions\n  ! Physics: Plane stress constitutive equations\n  ! Integration: Gauss quadrature\n  ! Assembly: Element stiffness contribution\nEND\n\nConsequence: Change anything â†’ must modify the entire element type. Want reduced integration? Create CPS3R. Want hybrid formulation? Create CPS3H. Exponential explosion.","category":"section"},{"location":"philosophy/#**O**-Open/Closed-Principle","page":"Philosophy","title":"O - Open/Closed Principle âŒ","text":"Principle: \"Software should be open for extension, closed for modification.\"\n\nABAQUS Violation: Cannot add new physics without modifying the codebase:\n\nWant new physics formulation?\n1. Create N new element types (one per topology)\n2. Modify element registry\n3. Duplicate shape functions and integration\n4. Update documentation, tests, manuals\n\nModern approach (extension without modification):\n\n# Add new physics - zero modifications to existing code\nstruct HyperelasticFormulation end\n\nfunction stiffness(elem::Tri3, phys::HyperelasticFormulation, integ::FullIntegration)\n    # New behavior via multiple dispatch\n    # Tri3 code unchanged\nend","category":"section"},{"location":"philosophy/#**L**-Liskov-Substitution-Principle","page":"Philosophy","title":"L - Liskov Substitution Principle âŒ","text":"Principle: \"Derived classes must be substitutable for their base classes.\"\n\nABAQUS Violation: Cannot substitute CPS3 for CPE3 even though they're the same topology:\n\n! These SHOULD be interchangeable (same topology)\n! But they're not - different physics hardcoded\nCALL ELEMENT_STIFFNESS(elem_type='CPS3', ...)  ! Plane stress\nCALL ELEMENT_STIFFNESS(elem_type='CPE3', ...)  ! Plane strain\n\n! Cannot substitute! Different hardcoded behavior\n\nModern approach (proper substitution):\n\n# Same topology, different physics - fully substitutable\nfunction solve(topology::Triangle3Node, physics::PhysicsModel)\n    # Topology is substitutable, physics is parameter\nend\n\nsolve(Tri3([1,2,3]), PlaneStress())   # âœ“ Works\nsolve(Tri3([1,2,3]), PlaneStrain())   # âœ“ Same topology, different physics","category":"section"},{"location":"philosophy/#**I**-Interface-Segregation-Principle","page":"Philosophy","title":"I - Interface Segregation Principle âŒ","text":"Principle: \"Clients shouldn't depend on interfaces they don't use.\"\n\nABAQUS Violation: Element types expose everything even when only topology is needed:\n\n! Just need connectivity for visualization\nCALL GET_ELEMENT_NODES(elem_type='C3D20', ...)\n\n! But C3D20 includes:\n! - 20-node hexahedron topology          (NEEDED)\n! - 3D stress formulation                (NOT NEEDED)\n! - Quadratic shape functions            (NOT NEEDED)\n! - Integration point data               (NOT NEEDED)\n! - Material interface                   (NOT NEEDED)\n\n! Fat interface - 80% irrelevant for this use case\n\nModern approach (segregated interfaces):\n\n# Topology interface (what AbaqusReader provides)\ntopology = Hex20([1,2,3,...,20])  # Just connectivity\nnodes = get_nodes(topology)        # Simple, focused interface\n\n# Physics interface (user adds if needed)\nphysics = ThreeDimensionalStress()\nstiffness = compute(topology, physics)  # Separate concerns","category":"section"},{"location":"philosophy/#**D**-Dependency-Inversion-Principle","page":"Philosophy","title":"D - Dependency Inversion Principle âŒ","text":"Principle: \"Depend on abstractions, not concretions.\"\n\nABAQUS Violation: Everything depends on concrete element type names:\n\n! Tight coupling to concrete types\nIF (elem_type == 'CPS3') THEN\n  CALL CPS3_ROUTINE(...)\nELSEIF (elem_type == 'CPE3') THEN\n  CALL CPE3_ROUTINE(...)\nELSEIF (elem_type == 'CAX3') THEN\n  CALL CAX3_ROUTINE(...)\n! ... 240+ more cases\nENDIF\n\n! Cannot abstract! Concrete type names everywhere\n\nModern approach (depend on abstractions):\n\n# Abstract interfaces\nabstract type Element end\nabstract type Physics end\n\n# Concrete implementations\nstruct Tri3 <: Element end\nstruct PlaneStress <: Physics end\n\n# Depend on abstraction, not concretions\nfunction stiffness(elem::Element, phys::Physics)\n    # Works with ANY element and physics type\n    # Multiple dispatch resolves concrete behavior\nend\n\n","category":"section"},{"location":"philosophy/#SOLID-Violations-Summary","page":"Philosophy","title":"SOLID Violations Summary","text":"Principle ABAQUS Violation Consequence\nSingle Responsibility Element types do topology + physics + integration Change one aspect â†’ modify entire type\nOpen/Closed Cannot extend without modifying codebase Adding features requires code changes\nLiskov Substitution Same topology types not substitutable Cannot abstract over topology\nInterface Segregation Fat interfaces expose everything Clients depend on unused functionality\nDependency Inversion Depends on concrete type names Tight coupling, hard to abstract\n\nResult: Unmaintainable, unextensible, O(exponential) complexity.\n\n","category":"section"},{"location":"philosophy/#Additional-Design-Violations","page":"Philosophy","title":"Additional Design Violations","text":"","category":"section"},{"location":"philosophy/#Violates-Separation-of-Concerns","page":"Philosophy","title":"Violates Separation of Concerns","text":"Topology and physics are orthogonal - they vary independently, but ABAQUS couples them.","category":"section"},{"location":"philosophy/#Violates-DRY-(Don't-Repeat-Yourself)","page":"Philosophy","title":"Violates DRY (Don't Repeat Yourself)","text":"! Same shape functions duplicated across physics variants\nSUBROUTINE CPS3_STIFFNESS(...)\n  ! Shape functions for 3-node triangle\nEND\n\nSUBROUTINE CPE3_STIFFNESS(...)\n  ! Shape functions for 3-node triangle  (DUPLICATED!)\nEND\n\nSUBROUTINE CAX3_STIFFNESS(...)\n  ! Shape functions for 3-node triangle  (DUPLICATED!)\nEND","category":"section"},{"location":"philosophy/#Not-Composable","page":"Philosophy","title":"Not Composable","text":"Modern software composes behavior:\n\nstiffness = topology âˆ˜ physics âˆ˜ integration\n\nABAQUS has monolithic types instead. No composition, no reuse.\n\n","category":"section"},{"location":"philosophy/#The-Modern-Solution:-Separation-via-Type-Systems","page":"Philosophy","title":"The Modern Solution: Separation via Type Systems","text":"","category":"section"},{"location":"philosophy/#What-We-Should-Do-(Julia-Multiple-Dispatch)","page":"Philosophy","title":"What We Should Do (Julia Multiple Dispatch)","text":"# Define concerns independently\nstruct Tri3 \n    nodes::Vector{Int}  # Topology only - geometry\nend\n\nstruct Quad4\n    nodes::Vector{Int}\nend\n\n# Physics formulations - separate types\nstruct PlaneStress end\nstruct PlaneStrain end\nstruct Axisymmetric end\n\n# Integration schemes - separate types\nstruct FullIntegration end\nstruct ReducedIntegration end\n\n# Compose via multiple dispatch\nfunction stiffness(elem::Tri3, phys::PlaneStress, integ::FullIntegration)\n    # Only this specific combination\nend\n\nfunction stiffness(elem::Tri3, phys::PlaneStrain, integ::FullIntegration)\n    # Different physics, same topology - reuses Tri3 shape functions\nend\n\n# Extensibility: Add new physics without touching topology\nstruct NonlinearElastic end\n\nfunction stiffness(elem::Tri3, phys::NonlinearElastic, integ::FullIntegration)\n    # New physics, existing topology - zero modifications to Tri3 code\nend\n\nComplexity: O(T + P + I) types instead of O(T Ã— P Ã— I)\n\nResult: 19 types instead of 240","category":"section"},{"location":"philosophy/#C-Templates","page":"Philosophy","title":"C++ Templates","text":"// Topology\ntemplate<int N>\nclass Triangle { \n    std::array<int, N> nodes; \n};\n\n// Compose at compile time\ntemplate<typename Physics, typename Integration>\nMatrix stiffness(Triangle<3>& elem, Physics p, Integration i) {\n    // Specialized per combination\n    // Zero runtime overhead\n}\n\n// Extensibility: Add new physics\nstruct NewPhysics { };\n\n// Automatically works with all topologies!","category":"section"},{"location":"philosophy/#Rust-Traits","page":"Philosophy","title":"Rust Traits","text":"// Separate traits for each concern\ntrait Element {\n    fn nodes(&self) -> &[usize];\n}\n\ntrait Formulation {\n    fn stress_state(&self) -> StressState;\n}\n\ntrait Quadrature {\n    fn points(&self) -> Vec<Point>;\n}\n\n// Compose orthogonally\nfn solve<E: Element, F: Formulation, Q: Quadrature>(\n    elem: &E, form: &F, quad: &Q\n) {\n    // Type system ensures valid combinations\n}\n\n","category":"section"},{"location":"philosophy/#Why-ABAQUS-Is-This-Way:-Historical-Context","page":"Philosophy","title":"Why ABAQUS Is This Way: Historical Context","text":"","category":"section"},{"location":"philosophy/#1970s-FORTRAN-Legacy","page":"Philosophy","title":"1970s FORTRAN Legacy","text":"ABAQUS originated in the 1970s when:\n\nFORTRAN was the dominant language\nProcedural programming was the only paradigm\nSubroutines were the abstraction mechanism\nTemplates, traits, and multiple dispatch didn't exist\n\nDesign consequence: Each element type = one subroutine. Different behavior = different subroutine.","category":"section"},{"location":"philosophy/#Technical-Debt-Accumulation","page":"Philosophy","title":"Technical Debt Accumulation","text":"After 40+ years:\n\nCannot break existing input files (millions of them exist)\nBackward compatibility is absolute requirement\nRefactoring is commercially impossible\n\"Add feature\" â†’ \"add element type\" became the pattern\n\nResult: Architecture frozen in 1970s paradigm despite modern alternatives.","category":"section"},{"location":"philosophy/#Why-Dassault-Didn't-Fix-It","page":"Philosophy","title":"Why Dassault Didn't Fix It","text":"Legacy inertia - Too much existing code to refactor\nBackward compatibility trap - Must support ancient input files\nFeature-driven development - Add features by adding types, not abstraction\nNo architectural vision - No incentive to refactor what \"works\"\n\nABAQUS is a powerful product with terrible architecture. A warning example for software engineering education.\n\n","category":"section"},{"location":"philosophy/#AbaqusReader's-Solution","page":"Philosophy","title":"AbaqusReader's Solution","text":"","category":"section"},{"location":"philosophy/#What-We-Do","page":"Philosophy","title":"What We Do","text":"We extract topology separately from physics:\n\nmesh = abaqus_read_mesh(\"model.inp\")\n\n# Returns:\nmesh[\"elements\"][1] = [1, 2, 3]              # Connectivity\nmesh[\"element_types\"][1] = :Tri3             # Topological type  \nmesh[\"element_codes\"][1] = :CPS3             # Original ABAQUS name\n\nUsers compose their own physics:\n\n# User's FEM code\nelem = Tri3(mesh[\"elements\"][1])\ncode = mesh[\"element_codes\"][1]  # :CPS3 tells us it was plane stress\n\nphysics = if code == :CPS3\n    PlaneStress()\nelseif code == :CPE3\n    PlaneStrain()\nelse\n    error(\"Unknown physics for $code\")\nend\n\nK = stiffness(elem, physics)  # Clean composition","category":"section"},{"location":"philosophy/#Why-This-Is-Correct","page":"Philosophy","title":"Why This Is Correct","text":"Separation of concerns - Topology independent of physics\nLinear complexity - 15 topological types vs. ABAQUS's 100+\nExtensible - Add physics without touching topology code\nComposable - Users build behavior from orthogonal pieces\nModern - Uses Julia's type system properly","category":"section"},{"location":"philosophy/#What-We-Preserve","page":"Philosophy","title":"What We Preserve","text":"âœ“ Original ABAQUS element names in element_codes (full traceability)\nâœ“ Node connectivity and numbering\nâœ“ Element sets and surfaces\nâœ“ Material names (but not properties - that's physics)","category":"section"},{"location":"philosophy/#What-We-Don't-Replicate","page":"Philosophy","title":"What We Don't Replicate","text":"âœ— ABAQUS's element type proliferation\nâœ— Coupling topology with physics\nâœ— Exponential complexity\nâœ— Code duplication\n\nWe're software engineers. We insulate Julia users from ABAQUS's architectural problems.\n\n","category":"section"},{"location":"philosophy/#For-Educators:-Using-ABAQUS-as-a-Teaching-Example","page":"Philosophy","title":"For Educators: Using ABAQUS as a Teaching Example","text":"ABAQUS is a perfect case study for teaching software engineering principles because it demonstrates clear violations of established best practices.","category":"section"},{"location":"philosophy/#What-This-Demonstrates","page":"Philosophy","title":"What This Demonstrates","text":"SOLID Principles - All five violated in one design\nSeparation of Concerns - Orthogonal dimensions mixed together\nComplexity Analysis - Exponential vs. linear growth patterns\nTechnical Debt - How poor decisions compound over decades\nType System Design - Using language features vs. nomenclature hacks\nMaintainability - Why extensibility matters from day one","category":"section"},{"location":"philosophy/#Design-Review-Questions","page":"Philosophy","title":"Design Review Questions","text":"When reviewing any software design, ask these questions:","category":"section"},{"location":"philosophy/#1.-**Single-Responsibility**","page":"Philosophy","title":"1. Single Responsibility","text":"Does each class/type have exactly one reason to change?\nAre multiple concerns bundled together?\nABAQUS Example: Element types mix topology + physics + integration","category":"section"},{"location":"philosophy/#2.-**Open/Closed**","page":"Philosophy","title":"2. Open/Closed","text":"Can I add features without modifying existing code?\nWill adding dimension X require creating NÃ—M variants?\nABAQUS Example: New physics â†’ must create N new element types","category":"section"},{"location":"philosophy/#3.-**Liskov-Substitution**","page":"Philosophy","title":"3. Liskov Substitution","text":"Are similar types truly interchangeable?\nCan I abstract over categories?\nABAQUS Example: CPS3 and CPE3 both triangles, but not substitutable","category":"section"},{"location":"philosophy/#4.-**Interface-Segregation**","page":"Philosophy","title":"4. Interface Segregation","text":"Do clients depend on functionality they don't use?\nAre interfaces fat or focused?\nABAQUS Example: Need topology? Get physics too (unwanted)","category":"section"},{"location":"philosophy/#5.-**Dependency-Inversion**","page":"Philosophy","title":"5. Dependency Inversion","text":"Do I depend on abstractions or concrete types?\nAm I coupled to specific implementations?\nABAQUS Example: Hardcoded element type name strings everywhere","category":"section"},{"location":"philosophy/#6.-**Are-Concerns-Orthogonal?**","page":"Philosophy","title":"6. Are Concerns Orthogonal?","text":"Do these dimensions vary independently?\nIf YES â†’ Separate types that compose\nIf NO â†’ Single abstraction may be OK\nABAQUS Example: Topology and physics are orthogonal but coupled","category":"section"},{"location":"philosophy/#7.-**Am-I-Creating-Exponential-Complexity?**","page":"Philosophy","title":"7. Am I Creating Exponential Complexity?","text":"Will adding dimension X require variants of all Y?\nIf YES â†’ You're creating exponential explosion\nIf NO â†’ Good, concerns are separated\nABAQUS Example: T Ã— P Ã— I Ã— F = 240+ types","category":"section"},{"location":"philosophy/#The-Lessons","page":"Philosophy","title":"The Lessons","text":"âŒ Don't Do This (ABAQUS) âœ… Do This (Modern)\nViolate all five SOLID principles Follow SOLID for maintainability\nMix orthogonal concerns in type names Separate concerns into independent types\nUse nomenclature instead of type system Use language features (templates/traits/dispatch)\nDuplicate code across variants Compose at call site\nCreate O(exponential) type proliferation Design for O(linear) extensibility\nDesign for immediate needs only Design for growth from day one\nLet compatibility prevent improvement Refactor early before debt compounds\nDepend on concrete type names Depend on abstractions","category":"section"},{"location":"philosophy/#Teaching-Exercise","page":"Philosophy","title":"Teaching Exercise","text":"Give students this scenario: \"You're designing a FEM library. You need to support:\n\n10 element topologies (triangles, quads, tets, hexes, etc.)\n5 physics formulations (plane stress, plane strain, 3D, axisymmetric, shells)\n3 integration schemes (full, reduced, selective)\n2 special features (hybrid, incompatible modes)\n\nBad approach (ABAQUS style): Create 10 Ã— 5 Ã— 3 Ã— 2 = 300 element type classes\n\nGood approach (modern style): Create 10 + 5 + 3 + 2 = 20 types that compose\n\nDiscussion points:\n\nWhich violates SOLID? (Bad approach violates all five)\nWhich is easier to extend? (Good approach: add one type, not 60)\nWhich has less code duplication? (Good approach: DRY)\nWhat happens when you add dimension 5? (Bad: 300â†’1500 types, Good: 20â†’25 types)\n\n","category":"section"},{"location":"philosophy/#Summary:-ABAQUS-as-a-Warning","page":"Philosophy","title":"Summary: ABAQUS as a Warning","text":"Aspect ABAQUS (Wrong) Modern Approach (Right)\nSOLID Principles Violates all five Follows all five\nConcerns Mixed in type names Separated into types\nComplexity O(exponential) O(linear)\nExtensibility Modify + duplicate Extend via composition\nCode Reuse Heavy duplication Single implementation\nParadigm 1970s procedural Modern functional/OOP\nType System Nomenclature-based Language feature-based","category":"section"},{"location":"philosophy/#Bottom-Line","page":"Philosophy","title":"Bottom Line","text":"ABAQUS demonstrates what NOT to do. Modern languages show how to do it right.\n\nAs proud software engineers, we should call out bad design when we see it - even in commercial products. Learn from both.\n\n","category":"section"},{"location":"philosophy/#See-Also","page":"Philosophy","title":"See Also","text":"Supported Elements - Complete element type listing\nExamples - Usage examples\nHome - Quick start guide","category":"section"},{"location":"#AbaqusReader.jl","page":"Home","title":"AbaqusReader.jl","text":"(Image: AbaqusReader.jl - Modern FEM Mesh Parser)\n\nParse ABAQUS input files in Julia with a clean, modern API.\n\nAbaqusReader.jl provides two distinct approaches for working with ABAQUS .inp files:\n\nMesh-only parsing for quick geometry extraction\nComplete model parsing for full simulation definitions\n\nDesign Philosophy: We provide topology (geometry and connectivity), not physics (formulations and behavior). Read our Philosophy to understand why we reject ABAQUS's element proliferation and embrace clean, topological types instead.\n\n\n\n<div style=\"text-align: center; margin: 2em 0; padding: 2em; background: linear-gradient(135deg, #9558B2 0%, #389826 100%); border-radius: 8px;\">\n  <button onclick=\"document.getElementById('visualizer-container').style.display='block'; this.parentElement.style.display='none';\" \n          style=\"background: white; color: #9558B2; border: none; padding: 15px 40px; font-size: 18px; font-weight: bold; border-radius: 5px; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.1);\">\n    ðŸš€ Open Interactive Visualizer\n  </button>\n  <p style=\"color: white; margin-top: 10px; font-size: 14px;\">\n    Drag & drop your ABAQUS .inp files â€¢ Visualize meshes in 3D â€¢ No installation required\n  </p>\n</div>\n\n<div id=\"visualizer-container\" style=\"display: none; margin: 2em 0;\">\n  <iframe src=\"assets/visualizer/index.html\" \n          style=\"width: 100%; height: 800px; border: 2px solid #9558B2; border-radius: 8px;\" \n          title=\"AbaqusReader.jl Interactive Visualizer\">\n  </iframe>\n  <p style=\"text-align: center; margin-top: 10px;\">\n    <button onclick=\"document.getElementById('visualizer-container').style.display='none'; document.querySelector('[onclick*=visualizer-container]').parentElement.style.display='block';\" \n            style=\"background: #9558B2; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;\">\n      âœ• Close Visualizer\n    </button>\n  </p>\n</div>\n\n","category":"section"},{"location":"#Two-Approaches-for-Two-Different-Needs","page":"Home","title":"Two Approaches for Two Different Needs","text":"","category":"section"},{"location":"#1.-Mesh-Only-Parsing-abaqus_read_mesh()","page":"Home","title":"1. Mesh-Only Parsing - abaqus_read_mesh()","text":"Fast and lightweight - extracts only the geometry and topology (nodes, elements, sets).\n\nReturns a simple Dict structure perfect for:\n\nðŸŽ¨ Visualizing geometry\nðŸ”„ Converting meshes to other formats\nðŸ” Quick mesh inspection\nðŸ› ï¸ Building custom FEM implementations\n\nUse when: You need the mesh structure but not the physics.","category":"section"},{"location":"#2.-Complete-Model-Parsing-abaqus_read_model()","page":"Home","title":"2. Complete Model Parsing - abaqus_read_model()","text":"Full simulation recipe - parses everything needed to reproduce the analysis.\n\nReturns a structured Model object containing:\n\nðŸ“ Mesh (nodes, elements, sets, surfaces)\nðŸ§± Materials and properties\nðŸ“ Boundary conditions and loads\nðŸ“Š Analysis steps and outputs\n\nUse when: You need to understand or reproduce the complete simulation setup.\n\n","category":"section"},{"location":"#Important-Notes","page":"Home","title":"Important Notes","text":"File Format: Both functions work best with \"flat\" ABAQUS input files. Structured formats (parts, assemblies) may have limited support.\nKeyword Coverage: abaqus_read_model() handles common ABAQUS keywords but doesn't cover every possible option. It's designed for typical simulation extraction use cases.\nElement Types: We use clean topological types (Tri3, Quad4, Tet4, Hex8) instead of ABAQUS's physics-specific nomenclature. Original names are preserved in metadata for traceability.","category":"section"},{"location":"lessons_learned/#Lessons-Learned:-Building-a-Modern-Parser-for-Legacy-FEM-Software","page":"Lessons Learned","title":"Lessons Learned: Building a Modern Parser for Legacy FEM Software","text":"A Software Engineering Journey with AbaqusReader.jl\n\nBy Jukka Aho\n\n","category":"section"},{"location":"lessons_learned/#The-Story","page":"Lessons Learned","title":"The Story","text":"","category":"section"},{"location":"lessons_learned/#The-Problem-I-Faced","page":"Lessons Learned","title":"The Problem I Faced","text":"I've been working in computational engineering for years, using ABAQUS as the primary FEM tool. It's powerful, mature, and has decades of development behind it. But as a software engineer who cares about code quality, I kept running into the same frustration:\n\nABAQUS's element type system is fundamentally broken from a software design perspective.\n\nWhen I needed to read ABAQUS input files in Julia for the JuliaFEM project, I had a choice:\n\nReplicate ABAQUS's design (easy path - just map their types)\nFix it properly (hard path - rethink the architecture)\n\nI chose the hard path. This is why, and what I learned.\n\n","category":"section"},{"location":"lessons_learned/#The-Wake-Up-Call","page":"Lessons Learned","title":"The Wake-Up Call","text":"","category":"section"},{"location":"lessons_learned/#Discovering-the-Exponential-Explosion","page":"Lessons Learned","title":"Discovering the Exponential Explosion","text":"ABAQUS has 100+ element types. When I started cataloging them, I noticed a pattern:\n\nCPS3  = 3-node triangle + Plane Stress\nCPE3  = 3-node triangle + Plane Strain  \nCAX3  = 3-node triangle + Axisymmetric\nC3D3  = 3-node triangle + 3D\n\nCPS4  = 4-node quad + Plane Stress\nCPE4  = 4-node quad + Plane Strain\nCAX4  = 4-node quad + Axisymmetric\nC3D4  = 4-node quad + 3D (tetrahedron)\n...\n\nSame topology, different physics. But each is a completely separate type.\n\nThe math hit me: Types = Topologies Ã— Physics Ã— Integration Ã— Features\n\nWith 10 topologies, 4 physics models, 3 integration schemes, and 2 features, you get 240 element types. And ABAQUS has even more dimensions than that.\n\nThis is O(exponential) complexity. As a software engineer, alarm bells went off.\n\n","category":"section"},{"location":"lessons_learned/#The-SOLID-Revelation","page":"Lessons Learned","title":"The SOLID Revelation","text":"","category":"section"},{"location":"lessons_learned/#When-Theory-Meets-Practice","page":"Lessons Learned","title":"When Theory Meets Practice","text":"I teach software engineering. I know SOLID principles. But seeing them all violated in one design was eye-opening:\n\nSingle Responsibility: Elements handle topology + physics + integration + features\nOpen/Closed: Can't add new physics without modifying everything\nLiskov Substitution: CPS3 and CPE3 both triangles, but not substitutable\nInterface Segregation: Need topology? Get physics too (unwanted coupling)\nDependency Inversion: Everything depends on concrete type name strings\n\nEvery. Single. One. Violated.\n\nThis wasn't just \"suboptimal design\" - this was a textbook example of what not to do.\n\n","category":"section"},{"location":"lessons_learned/#The-Decision:-Don't-Replicate-Mistakes","page":"Lessons Learned","title":"The Decision: Don't Replicate Mistakes","text":"","category":"section"},{"location":"lessons_learned/#Why-I-Didn't-Just-Map-ABAQUS-Types","page":"Lessons Learned","title":"Why I Didn't Just Map ABAQUS Types","text":"The easy path would be:\n\n# Just map their types directly\nstruct CPS3 end\nstruct CPE3 end\nstruct CAX3 end\n# ... 100+ more structs\n\nBut this would:\n\nImport the architectural problems into Julia\nCouple Julia code to ABAQUS's mistakes\nPrevent proper abstraction over topology\nMiss the opportunity to do it right\n\nAs proud software engineers building modern FEM tools, we can do better.\n\n","category":"section"},{"location":"lessons_learned/#The-Solution:-Separation-of-Concerns","page":"Lessons Learned","title":"The Solution: Separation of Concerns","text":"","category":"section"},{"location":"lessons_learned/#What-AbaqusReader.jl-Actually-Does","page":"Lessons Learned","title":"What AbaqusReader.jl Actually Does","text":"mesh = abaqus_read_mesh(\"model.inp\")\n\n# Returns clean topology\nmesh[\"element_types\"][1] = :Tri3              # Topological type only\nmesh[\"element_codes\"][1] = :CPS3              # Original ABAQUS name preserved\n\n# Users compose their own physics\nelem = Tri3(mesh[\"elements\"][1])              # Clean topology\nphysics = infer_physics(mesh[\"element_codes\"][1])  # User's choice\nK = stiffness(elem, physics)                  # Proper composition\n\nKey principles:\n\nTopology separated from physics - orthogonal concerns stay separate\nOriginal names preserved - full traceability to ABAQUS\nLinear complexity - 15 topological types instead of 100+\nExtensible - add physics without touching topology code\nComposable - users build behavior from orthogonal pieces\n\n","category":"section"},{"location":"lessons_learned/#What-I-Learned","page":"Lessons Learned","title":"What I Learned","text":"","category":"section"},{"location":"lessons_learned/#Lesson-1:-Legacy-Best-Practice","page":"Lessons Learned","title":"Lesson 1: Legacy â‰  Best Practice","text":"Just because software is old, mature, and commercially successful doesn't mean its architecture is good.\n\nABAQUS dates from the 1970s, when:\n\nFORTRAN was the only option\nProcedural programming was standard\nType systems were primitive\nTemplates, traits, and multiple dispatch didn't exist\n\nThe design made sense then. But frozen in that paradigm for 50 years, it became a warning example.\n\nKey insight: Respect the domain expertise (FEM algorithms), reject the architectural mistakes.","category":"section"},{"location":"lessons_learned/#Lesson-2:-Separation-of-Concerns-is-Not-Academic","page":"Lessons Learned","title":"Lesson 2: Separation of Concerns is Not Academic","text":"I used to think \"separation of concerns\" was abstract theory. Then I hit exponential type proliferation.\n\nOrthogonal concerns that aren't separated lead to exponential complexity.\n\nTopology and physics are mathematically independent:\n\nAny topology works with any physics\nChanging topology shouldn't affect physics code\nChanging physics shouldn't affect topology code\n\nWhen ABAQUS coupled them, they created 100+ types. When we separated them, we got 15.\n\nKey insight: Orthogonality in the problem domain should be orthogonality in the code.","category":"section"},{"location":"lessons_learned/#Lesson-3:-Modern-Language-Features-Exist-For-This","page":"Lessons Learned","title":"Lesson 3: Modern Language Features Exist For This","text":"Julia's multiple dispatch is designed for this problem:\n\n# Define concerns separately\nstruct Tri3 <: Element end\nstruct PlaneStress <: Physics end\nstruct FullIntegration <: Integration end\n\n# Compose at call site\nfunction stiffness(e::Element, p::Physics, i::Integration)\n    # Specialized automatically via multiple dispatch\nend\n\n# Extensibility: add new physics\nstruct Hyperelastic <: Physics end\n\n# Works automatically with all existing topologies!\n\nC++ templates, Rust traits, and Haskell type classes solve the same problem.\n\nModern languages have features specifically designed to prevent exponential type proliferation.\n\nABAQUS is stuck in 1970s FORTRAN procedural thinking, where the only abstraction mechanism was \"different subroutine = different behavior\".\n\nKey insight: Use your language's type system properly. It exists for exactly this reason.","category":"section"},{"location":"lessons_learned/#Lesson-4:-Compatibility-Traps-Are-Real","page":"Lessons Learned","title":"Lesson 4: Compatibility Traps Are Real","text":"ABAQUS knows their element design is problematic. But they can't fix it because:\n\nMillions of existing input files depend on exact element type names\nCommercial users depend on backward compatibility\nRefactoring would break everything\n\nThis is technical debt that became unpayable.\n\nThe lesson: Design for extensibility from day one. Once you ship exponential complexity, you're stuck with it forever.\n\nKey insight: Poor architectural decisions compound over decades. Fix them early or live with them forever.","category":"section"},{"location":"lessons_learned/#Lesson-5:-Sometimes-You-Should-Say-\"No\"","page":"Lessons Learned","title":"Lesson 5: Sometimes You Should Say \"No\"","text":"The hardest decision was: Should AbaqusReader.jl replicate ABAQUS's type system?\n\nUsers might expect it. It would be \"compatible\" with ABAQUS thinking. Some might complain that we \"don't follow the standard.\"\n\nBut here's the thing: We're not obligated to replicate bad design.\n\nWe support the format (interoperability). We preserve the names (traceability). But we don't replicate the architecture (mistakes).\n\nAs software engineers, it's our responsibility to insulate users from bad design decisions made 50 years ago.\n\nKey insight: Interoperability doesn't mean replicating mistakes. You can support a format without importing its flaws.\n\n","category":"section"},{"location":"lessons_learned/#The-Bigger-Picture","page":"Lessons Learned","title":"The Bigger Picture","text":"","category":"section"},{"location":"lessons_learned/#Why-This-Matters-Beyond-ABAQUS","page":"Lessons Learned","title":"Why This Matters Beyond ABAQUS","text":"This isn't just about FEM or ABAQUS. The lessons apply everywhere:","category":"section"},{"location":"lessons_learned/#In-Scientific-Computing","page":"Lessons Learned","title":"In Scientific Computing","text":"Many scientific codes date from the 1970s-1990s. They have deep domain expertise but dated software architecture. When building modern tools that interface with them:\n\nExtract the science (algorithms, methods)\nReject the architecture (if it violates modern principles)\nProvide clean interfaces for new code","category":"section"},{"location":"lessons_learned/#In-Data-Engineering","page":"Lessons Learned","title":"In Data Engineering","text":"Legacy data formats often have structural problems. When building parsers:\n\nParse faithfully (preserve all information)\nTransform to clean structures (separation of concerns)\nDon't import the mess into your codebase","category":"section"},{"location":"lessons_learned/#In-API-Design","page":"Lessons Learned","title":"In API Design","text":"When building libraries, think about extensibility:\n\nWill adding dimension X require N new types? â†’ You're creating exponential complexity\nAre orthogonal concerns coupled? â†’ Separate them now, or pay later\nCan users extend without modifying your code? â†’ If not, refactor\n\n","category":"section"},{"location":"lessons_learned/#For-Educators","page":"Lessons Learned","title":"For Educators","text":"","category":"section"},{"location":"lessons_learned/#Teaching-SOLID-with-Real-Examples","page":"Lessons Learned","title":"Teaching SOLID with Real Examples","text":"ABAQUS is a perfect teaching tool for software engineering because:\n\nIt's real - Not a toy example, but a major commercial product\nIt violates all SOLID principles - Clear, concrete violations\nThe consequences are visible - 100+ types, code duplication, unmaintainability\nThe fix is obvious - Separation of concerns via modern type systems\nThe lesson generalizes - Same pattern appears in many domains\n\nClassroom exercise I now use:\n\n\"You're designing a FEM library. You need 10 topologies, 5 physics models, 3 integration schemes, 2 features. Do you create 300 element types or 20 composable types? Discuss the SOLID implications.\"\n\nStudents immediately see why separation of concerns matters when faced with exponential vs. linear complexity.\n\n","category":"section"},{"location":"lessons_learned/#Conclusion:-Pride-in-Craft","page":"Lessons Learned","title":"Conclusion: Pride in Craft","text":"","category":"section"},{"location":"lessons_learned/#What-AbaqusReader.jl-Represents","page":"Lessons Learned","title":"What AbaqusReader.jl Represents","text":"This package is more than a parser. It's a statement about software engineering:\n\nWe respect domain expertise - ABAQUS's FEM algorithms are excellent\nWe reject architectural mistakes - Their type system is not\nWe design for the future - Linear complexity, extensibility, composition\nWe're proud of our craft - Software engineering principles matter","category":"section"},{"location":"lessons_learned/#The-Meta-Lesson","page":"Lessons Learned","title":"The Meta-Lesson","text":"Sometimes the most important contribution isn't the code - it's the decision of what NOT to replicate.\n\nBy refusing to import ABAQUS's exponential complexity into Julia, AbaqusReader.jl provides:\n\nA clean foundation for Julia FEM codes\nAn example of proper separation of concerns\nA teaching tool for software engineering principles\nA reminder that legacy doesn't mean best practice\n\n","category":"section"},{"location":"lessons_learned/#References-and-Further-Reading","page":"Lessons Learned","title":"References and Further Reading","text":"","category":"section"},{"location":"lessons_learned/#On-SOLID-Principles","page":"Lessons Learned","title":"On SOLID Principles","text":"Martin, R.C. (2000). Design Principles and Design Patterns\nMartin, R.C. (2017). Clean Architecture","category":"section"},{"location":"lessons_learned/#On-Separation-of-Concerns","page":"Lessons Learned","title":"On Separation of Concerns","text":"Dijkstra, E.W. (1982). \"On the role of scientific thought\"\nParnas, D.L. (1972). \"On the criteria to be used in decomposing systems into modules\"","category":"section"},{"location":"lessons_learned/#On-Type-System-Design","page":"Lessons Learned","title":"On Type System Design","text":"Pierce, B.C. (2002). Types and Programming Languages\nBezanson, J., et al. (2017). \"Julia: A fresh approach to numerical computing\"","category":"section"},{"location":"lessons_learned/#On-Technical-Debt","page":"Lessons Learned","title":"On Technical Debt","text":"Cunningham, W. (1992). \"The WyCash portfolio management system\"\nFowler, M. (2019). \"Technical Debt\" (martinfowler.com)\n\n","category":"section"},{"location":"lessons_learned/#Acknowledgments","page":"Lessons Learned","title":"Acknowledgments","text":"This work grew from the JuliaFEM project and discussions with the Julia community about proper abstraction and type design. Thanks to everyone who challenged me to articulate why ABAQUS's design felt wrong - that pressure led to this clarity.\n\nSpecial thanks to the Julia core team for creating a language with the right abstractions to solve this problem elegantly.\n\n\n\nWant to discuss these ideas? Open an issue on GitHub or find me in the Julia community.","category":"section"}]
}

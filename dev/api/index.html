<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · AbaqusReader.jl</title><meta name="title" content="API Reference · AbaqusReader.jl"/><meta property="og:title" content="API Reference · AbaqusReader.jl"/><meta property="twitter:title" content="API Reference · AbaqusReader.jl"/><meta name="description" content="Documentation for AbaqusReader.jl."/><meta property="og:description" content="Documentation for AbaqusReader.jl."/><meta property="twitter:description" content="Documentation for AbaqusReader.jl."/><meta property="og:url" content="https://ahojukka5.github.io/AbaqusReader.jl/api/"/><meta property="twitter:url" content="https://ahojukka5.github.io/AbaqusReader.jl/api/"/><link rel="canonical" href="https://ahojukka5.github.io/AbaqusReader.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbaqusReader.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../philosophy/">Philosophy</a></li><li><a class="tocitem" href="../lessons_learned/">Lessons Learned</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../elements/">Supported Elements</a></li><li><a class="tocitem" href="../element_database/">Element Database</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ahojukka5/AbaqusReader.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>AbaqusReader.jl exports the following main functions for working with ABAQUS input files:</p><ul><li>File-based API: <code>abaqus_read_mesh</code>, <code>abaqus_read_model</code> (read from .inp files)</li><li>String-based API: <code>abaqus_parse_mesh</code>, <code>abaqus_parse_model</code> (parse from string buffers)</li><li>Element registration: <code>register_element!</code> (add element types dynamically)</li><li>Utilities: <code>create_surface_elements</code>, <code>abaqus_download</code></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AbaqusReader.abaqus_download"><code>AbaqusReader.abaqus_download</code></a></li><li><a href="#AbaqusReader.abaqus_parse_mesh"><code>AbaqusReader.abaqus_parse_mesh</code></a></li><li><a href="#AbaqusReader.abaqus_parse_model"><code>AbaqusReader.abaqus_parse_model</code></a></li><li><a href="#AbaqusReader.abaqus_read_mesh"><code>AbaqusReader.abaqus_read_mesh</code></a></li><li><a href="#AbaqusReader.abaqus_read_model"><code>AbaqusReader.abaqus_read_model</code></a></li><li><a href="#AbaqusReader.create_surface_elements"><code>AbaqusReader.create_surface_elements</code></a></li><li><a href="#AbaqusReader.register_element!"><code>AbaqusReader.register_element!</code></a></li></ul><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="AbaqusReader.abaqus_read_mesh"><a class="docstring-binding" href="#AbaqusReader.abaqus_read_mesh"><code>AbaqusReader.abaqus_read_mesh</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">abaqus_read_mesh(fn::String) -&gt; Dict</code></pre><p>Read ABAQUS <code>.inp</code> file and extract mesh geometry and topology.</p><p>This function performs <strong>mesh-only parsing</strong>, extracting nodes, elements, sets, and surfaces without parsing materials, boundary conditions, or analysis steps. Use this when you only need the geometric structure of the model.</p><p><strong>Arguments</strong></p><ul><li><code>fn::String</code>: Path to the ABAQUS input file (<code>.inp</code>)</li></ul><p><strong>Returns</strong></p><p>A <code>Dict{String, Any}</code> containing:</p><ul><li><code>&quot;nodes&quot;</code>: <code>Dict{Int, Vector{Float64}}</code> - Node ID → coordinates [x, y, z]</li><li><code>&quot;elements&quot;</code>: <code>Dict{Int, Vector{Int}}</code> - Element ID → node connectivity</li><li><code>&quot;element_types&quot;</code>: <code>Dict{Int, Symbol}</code> - Element ID → topological type (e.g., <code>:Tet4</code>, <code>:Hex8</code>)</li><li><code>&quot;element_codes&quot;</code>: <code>Dict{Int, Symbol}</code> - Element ID → original ABAQUS element name (e.g., <code>:C3D8R</code>, <code>:CPS3</code>)</li><li><code>&quot;node_sets&quot;</code>: <code>Dict{String, Vector{Int}}</code> - Node set name → node IDs</li><li><code>&quot;element_sets&quot;</code>: <code>Dict{String, Vector{Int}}</code> - Element set name → element IDs</li><li><code>&quot;surface_sets&quot;</code>: <code>Dict{String, Vector{Tuple{Int, Symbol}}}</code> - Surface name → (element, face) pairs</li><li><code>&quot;surface_types&quot;</code>: <code>Dict{String, Symbol}</code> - Surface name → surface type (e.g., <code>:ELEMENT</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbaqusReader

# Read mesh from file
mesh = abaqus_read_mesh(&quot;model.inp&quot;)

# Access node coordinates
coords = mesh[&quot;nodes&quot;][1]  # [x, y, z] for node 1

# Get element connectivity
elem_nodes = mesh[&quot;elements&quot;][1]  # Node IDs for element 1

# Get topological element type
elem_type = mesh[&quot;element_types&quot;][1]  # e.g., :Hex8

# Get original ABAQUS element code
elem_code = mesh[&quot;element_codes&quot;][1]  # e.g., :C3D8R

# Get nodes in a set
boundary_nodes = mesh[&quot;node_sets&quot;][&quot;BOUNDARY&quot;]</code></pre><p><strong>See Also</strong></p><ul><li><a href="#AbaqusReader.abaqus_parse_mesh"><code>abaqus_parse_mesh</code></a>: Parse mesh from string buffer</li><li><a href="#AbaqusReader.abaqus_read_model"><code>abaqus_read_model</code></a>: Read complete model including materials and boundary conditions</li><li><a href="#AbaqusReader.create_surface_elements"><code>create_surface_elements</code></a>: Extract surface elements from surface definitions</li></ul><p><strong>Notes</strong></p><ul><li>Supports 60+ ABAQUS element types (see documentation for full list)</li><li>Returns simple dictionary structure for easy manipulation</li><li>Much faster than <code>abaqus_read_model</code> when only mesh is needed</li><li>Element types are mapped to generic topology (e.g., <code>C3D8R</code> → <code>:Hex8</code>)</li><li>Original ABAQUS element names preserved in <code>element_codes</code> for traceability</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/mesh/reader.jl#L56-L113">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.abaqus_parse_mesh"><a class="docstring-binding" href="#AbaqusReader.abaqus_parse_mesh"><code>AbaqusReader.abaqus_parse_mesh</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">abaqus_parse_mesh(content::AbstractString) -&gt; Dict</code></pre><p>Parse ABAQUS mesh from a string buffer.</p><p>This is the core parsing function that extracts mesh geometry and topology from ABAQUS input file content provided as a string. Use this when you have the content in memory or want to avoid file I/O in tests.</p><p><strong>Arguments</strong></p><ul><li><code>content::AbstractString</code>: ABAQUS input file content as a string</li></ul><p><strong>Returns</strong></p><p>Same dictionary structure as <code>abaqus_read_mesh</code>:</p><ul><li><code>&quot;nodes&quot;</code>: Node coordinates</li><li><code>&quot;elements&quot;</code>: Element connectivity</li><li><code>&quot;element_types&quot;</code>: Topological types</li><li><code>&quot;element_codes&quot;</code>: Original ABAQUS element names</li><li><code>&quot;node_sets&quot;</code>, <code>&quot;element_sets&quot;</code>, <code>&quot;surface_sets&quot;</code>: Named sets</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inp_content = &quot;&quot;&quot;
*NODE
1, 0.0, 0.0, 0.0
2, 1.0, 0.0, 0.0
*ELEMENT, TYPE=C3D8
1, 1, 2, 3, 4, 5, 6, 7, 8
&quot;&quot;&quot;

mesh = abaqus_parse_mesh(inp_content)</code></pre><p><strong>See Also</strong></p><ul><li><a href="#AbaqusReader.abaqus_read_mesh"><code>abaqus_read_mesh</code></a>: Read mesh from file</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/mesh/reader.jl#L4-L39">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.abaqus_read_model"><a class="docstring-binding" href="#AbaqusReader.abaqus_read_model"><code>AbaqusReader.abaqus_read_model</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">abaqus_read_model(fn::String) -&gt; Model</code></pre><p>Read complete ABAQUS model including mesh, materials, boundary conditions, and analysis steps.</p><p>This function performs <strong>complete model parsing</strong>, extracting the entire simulation definition from an ABAQUS input file. Use this when you need to reproduce or analyze the full simulation setup, not just the mesh geometry.</p><p><strong>Arguments</strong></p><ul><li><code>fn::String</code>: Path to the ABAQUS input file (<code>.inp</code>)</li></ul><p><strong>Returns</strong></p><p>An <code>AbaqusReader.Model</code> object with fields:</p><ul><li><code>path::String</code>: Directory containing the input file</li><li><code>name::String</code>: Model name (basename without extension)</li><li><code>mesh::Mesh</code>: Mesh object containing all geometric data<ul><li><code>mesh.nodes</code>: Node coordinates</li><li><code>mesh.elements</code>: Element connectivity</li><li><code>mesh.element_types</code>: Element type mapping</li><li><code>mesh.node_sets</code>: Named node sets</li><li><code>mesh.element_sets</code>: Named element sets</li><li><code>mesh.surface_sets</code>: Surface definitions</li></ul></li><li><code>materials::Dict</code>: Material definitions with properties<ul><li>Each material may contain elastic, density, plastic, etc.</li></ul></li><li><code>properties::Vector</code>: Section property assignments (linking materials to element sets)</li><li><code>boundary_conditions::Vector</code>: Prescribed displacements, constraints, etc.</li><li><code>steps::Vector</code>: Analysis steps with loads, BCs, and output requests</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbaqusReader

# Read complete model
model = abaqus_read_model(&quot;simulation.inp&quot;)

# Access mesh (same structure as abaqus_read_mesh)
nodes = model.mesh.nodes
elements = model.mesh.elements

# Access material properties
for (name, material) in model.materials
    println(&quot;Material: $name&quot;)
    for prop in material.properties
        if prop isa AbaqusReader.Elastic
            println(&quot;  E = $(prop.E), ν = $(prop.nu)&quot;)
        end
    end
end

# Iterate through boundary conditions
for bc in model.boundary_conditions
    println(&quot;BC type: $(bc.kind), data: $(bc.data)&quot;)
end

# Iterate through analysis steps
for step in model.steps
    println(&quot;Step type: $(step.kind)&quot;)
    println(&quot;  BCs: $(length(step.boundary_conditions))&quot;)
    println(&quot;  Outputs: $(length(step.output_requests))&quot;)
end</code></pre><p><strong>See Also</strong></p><ul><li><a href="#AbaqusReader.abaqus_parse_model"><code>abaqus_parse_model</code></a>: Parse model from string buffer</li><li><a href="#AbaqusReader.abaqus_read_mesh"><code>abaqus_read_mesh</code></a>: Read only mesh geometry (faster, simpler output)</li><li><a href="#AbaqusReader.create_surface_elements"><code>create_surface_elements</code></a>: Extract surface elements from model</li></ul><p><strong>Notes</strong></p><ul><li>Slower than <code>abaqus_read_mesh</code> as it parses the entire model</li><li>Returns structured <code>Model</code> object (not a simple Dict)</li><li>Parses most common ABAQUS keywords but not every possible option</li><li>Best suited for &quot;flat&quot; input files; structured part/assembly files may have limited support</li><li>Use when you need materials, BCs, loads, or analysis parameters</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/model/reader.jl#L86-L160">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.abaqus_parse_model"><a class="docstring-binding" href="#AbaqusReader.abaqus_parse_model"><code>AbaqusReader.abaqus_parse_model</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">abaqus_parse_model(content::AbstractString) -&gt; Model</code></pre><p>Parse complete ABAQUS model from a string buffer.</p><p>This is the core parsing function that extracts the entire simulation definition from ABAQUS input file content provided as a string. Use this when you have the content in memory, want to avoid file I/O in tests, or are working with generated input content.</p><p><strong>Arguments</strong></p><ul><li><code>content::AbstractString</code>: ABAQUS input file content as a string</li></ul><p><strong>Returns</strong></p><p>An <code>AbaqusReader.Model</code> object (same structure as <code>abaqus_read_model</code>)</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">inp_content = &quot;&quot;&quot;
*HEADING
Test model
*NODE
1, 0.0, 0.0, 0.0
*ELEMENT, TYPE=C3D8
1, 1, 2, 3, 4, 5, 6, 7, 8
*MATERIAL, NAME=STEEL
*ELASTIC
210000.0, 0.3
&quot;&quot;&quot;

model = abaqus_parse_model(inp_content)
println(&quot;Materials: &quot;, keys(model.materials))</code></pre><p><strong>See Also</strong></p><ul><li><a href="#AbaqusReader.abaqus_read_model"><code>abaqus_read_model</code></a>: Read model from file</li><li><a href="#AbaqusReader.abaqus_parse_mesh"><code>abaqus_parse_mesh</code></a>: Parse only mesh from string</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/model/reader.jl#L4-L41">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.register_element!"><a class="docstring-binding" href="#AbaqusReader.register_element!"><code>AbaqusReader.register_element!</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">register_element!(element_name::String, num_nodes::Int, element_type::String)</code></pre><p>Register a new element type dynamically without modifying the TOML database. Useful for handling element variations not yet in the database.</p><p><strong>Arguments</strong></p><ul><li><code>element_name</code>: ABAQUS element name (e.g., &quot;C3D10I&quot;, &quot;C3D8RT&quot;)</li><li><code>num_nodes</code>: Number of nodes in the element</li><li><code>element_type</code>: Topology type (e.g., &quot;Tet10&quot;, &quot;Hex8&quot;, &quot;Tri3&quot;, &quot;Quad4&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Register a C3D10I element (10-node incompatible mode tet)
register_element!(&quot;C3D10I&quot;, 10, &quot;Tet10&quot;)

# Now you can read meshes containing C3D10I elements
mesh = abaqus_read_mesh(&quot;model_with_c3d10i.inp&quot;)</code></pre><p>To make the element permanently available, consider adding it to  <code>data/abaqus_elements.toml</code> and submitting a pull request.</p><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/mesh/element_database.jl#L30-L52">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.create_surface_elements"><a class="docstring-binding" href="#AbaqusReader.create_surface_elements"><code>AbaqusReader.create_surface_elements</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">create_surface_elements(mesh::Dict, surface_name::String) -&gt; Vector{Tuple{Symbol, Vector{Int}}}</code></pre><p>Create explicit surface elements from an implicit surface definition in an ABAQUS mesh.</p><p>ABAQUS surfaces are typically defined implicitly as (element, face) pairs. This function converts those implicit definitions into explicit surface elements with their own connectivity, which is useful for applying boundary conditions, extracting surface nodes, or visualization.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Dict</code>: Mesh dictionary as returned by <a href="#AbaqusReader.abaqus_read_mesh"><code>abaqus_read_mesh</code></a></li><li><code>surface_name::String</code>: Name of the surface to extract (must exist in <code>mesh[&quot;surface_sets&quot;]</code>)</li></ul><p><strong>Returns</strong></p><p><code>Vector{Tuple{Symbol, Vector{Int}}}</code> where each tuple contains:</p><ul><li>Element type symbol (e.g., <code>:Tri3</code>, <code>:Quad4</code>) for the surface element</li><li>Node connectivity vector for that surface element</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbaqusReader

# Read mesh with surface definitions
mesh = abaqus_read_mesh(&quot;model.inp&quot;)

# Check available surfaces
println(&quot;Available surfaces: &quot;, keys(mesh[&quot;surface_sets&quot;]))

# Create surface elements for a named surface
surface_elems = create_surface_elements(mesh, &quot;LOAD_SURFACE&quot;)

# Extract unique nodes on the surface
surface_nodes = Set{Int}()
for (elem_type, connectivity) in surface_elems
    union!(surface_nodes, connectivity)
end
println(&quot;Surface has $(length(surface_nodes)) unique nodes&quot;)

# Get coordinates of surface nodes
surface_coords = [mesh[&quot;nodes&quot;][nid] for nid in surface_nodes]

# Apply boundary conditions to surface nodes
for node_id in surface_nodes
    # Apply BC at node_id...
end</code></pre><p><strong>Surface Element Types</strong></p><p>Depending on the parent volume element type and face, surface elements can be:</p><ul><li><code>:Tri3</code> - 3-node triangle (from tet faces, wedge faces)</li><li><code>:Tri6</code> - 6-node triangle (from quadratic tet faces)</li><li><code>:Quad4</code> - 4-node quadrilateral (from hex faces, wedge faces)</li><li><code>:Quad8</code> - 8-node quadrilateral (from quadratic hex faces)</li></ul><p><strong>See Also</strong></p><ul><li><a href="#AbaqusReader.abaqus_read_mesh"><code>abaqus_read_mesh</code></a>: Read mesh data containing surface definitions</li><li><a href="#AbaqusReader.abaqus_read_model"><code>abaqus_read_model</code></a>: Read complete model with surfaces</li></ul><p><strong>Notes</strong></p><ul><li>Surface must exist in <code>mesh[&quot;surface_sets&quot;]</code> or an error will be thrown</li><li>The parent elements referenced in the surface definition must exist in the mesh</li><li>Each (element, face) pair generates one surface element</li><li>Useful for extracting boundary nodes for applying loads or boundary conditions</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/create_surface_elements.jl#L52-L115">source</a></div></details></article><article><details class="docstring" open="true"><summary id="AbaqusReader.abaqus_download"><a class="docstring-binding" href="#AbaqusReader.abaqus_download"><code>AbaqusReader.abaqus_download</code></a> — <span class="docstring-category">Function</span></summary><div><pre><code class="language-julia hljs">abaqus_download(model_name, env=ENV; dryrun=false) -&gt; String</code></pre><p>Download an ABAQUS example model from a remote repository.</p><p>This utility function downloads example ABAQUS input files for testing and learning purposes. It requires environment variables to be set for specifying the download URL and destination.</p><p><strong>Arguments</strong></p><ul><li><code>model_name</code>: Name of the model file to download (e.g., <code>&quot;piston_ring_2d.inp&quot;</code>)</li><li><code>env</code>: Environment dictionary (defaults to <code>ENV</code>)</li><li><code>dryrun::Bool</code>: If <code>true</code>, skip actual download (for testing)</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Full path to the downloaded file</li><li>Returns path immediately if file already exists locally</li></ul><p><strong>Required Environment Variables</strong></p><ul><li><code>ABAQUS_DOWNLOAD_URL</code>: Base URL for downloading models<ul><li>Example: <code>&quot;https://example.com/models&quot;</code></li><li>The model file will be fetched from <code>$ABAQUS_DOWNLOAD_URL/$model_name</code></li></ul></li></ul><p><strong>Optional Environment Variables</strong></p><ul><li><code>ABAQUS_DOWNLOAD_DIR</code>: Directory where files will be saved<ul><li>Defaults to current directory if not set</li><li>Will create directory if it doesn&#39;t exist</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using AbaqusReader

# Set up environment variables
ENV[&quot;ABAQUS_DOWNLOAD_URL&quot;] = &quot;https://example.com/abaqus/models&quot;
ENV[&quot;ABAQUS_DOWNLOAD_DIR&quot;] = &quot;/path/to/models&quot;

# Download a model
filepath = abaqus_download(&quot;piston_ring_2d.inp&quot;)

# Use the downloaded file
mesh = abaqus_read_mesh(filepath)</code></pre><p><strong>Errors</strong></p><p>Throws an error if:</p><ul><li><code>ABAQUS_DOWNLOAD_URL</code> is not set and file doesn&#39;t exist locally</li><li>Download fails (network error, file not found, etc.)</li></ul><p><strong>Notes</strong></p><ul><li>Files are only downloaded once; subsequent calls return the existing file path</li><li>Useful for testing, tutorials, and reproducible examples</li><li>Check the AbaqusReader repository for available example models</li></ul><a class="docs-sourcelink" target="_blank" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/a90cd9f3587a63d193b464256d36b74f63d6f21b/src/abaqus_download.jl#L4-L55">source</a></div></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../element_database/">« Element Database</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">AbaqusReader.jl - Modern FEM mesh parser for Julia</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Friday 21 November 2025 23:25">Friday 21 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

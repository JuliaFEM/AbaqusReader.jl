<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Philosophy · AbaqusReader.jl</title><meta name="title" content="Philosophy · AbaqusReader.jl"/><meta property="og:title" content="Philosophy · AbaqusReader.jl"/><meta property="twitter:title" content="Philosophy · AbaqusReader.jl"/><meta name="description" content="Documentation for AbaqusReader.jl."/><meta property="og:description" content="Documentation for AbaqusReader.jl."/><meta property="twitter:description" content="Documentation for AbaqusReader.jl."/><meta property="og:url" content="https://ahojukka5.github.io/AbaqusReader.jl/philosophy/"/><meta property="twitter:url" content="https://ahojukka5.github.io/AbaqusReader.jl/philosophy/"/><link rel="canonical" href="https://ahojukka5.github.io/AbaqusReader.jl/philosophy/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AbaqusReader.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Philosophy</a><ul class="internal"><li><a class="tocitem" href="#Our-Position"><span>Our Position</span></a></li><li><a class="tocitem" href="#The-Problem:-Exponential-Complexity"><span>The Problem: Exponential Complexity</span></a></li><li><a class="tocitem" href="#Why-This-Is-Wrong:-SOLID-Principles-Violated"><span>Why This Is Wrong: SOLID Principles Violated</span></a></li><li><a class="tocitem" href="#SOLID-Violations-Summary"><span>SOLID Violations Summary</span></a></li><li><a class="tocitem" href="#Additional-Design-Violations"><span>Additional Design Violations</span></a></li><li><a class="tocitem" href="#The-Modern-Solution:-Separation-via-Type-Systems"><span>The Modern Solution: Separation via Type Systems</span></a></li><li><a class="tocitem" href="#Why-ABAQUS-Is-This-Way:-Historical-Context"><span>Why ABAQUS Is This Way: Historical Context</span></a></li><li><a class="tocitem" href="#AbaqusReader&#39;s-Solution"><span>AbaqusReader&#39;s Solution</span></a></li><li><a class="tocitem" href="#For-Educators:-Using-ABAQUS-as-a-Teaching-Example"><span>For Educators: Using ABAQUS as a Teaching Example</span></a></li><li><a class="tocitem" href="#Summary:-ABAQUS-as-a-Warning"><span>Summary: ABAQUS as a Warning</span></a></li><li><a class="tocitem" href="#See-Also"><span>See Also</span></a></li></ul></li><li><a class="tocitem" href="../lessons_learned/">Lessons Learned</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../elements/">Supported Elements</a></li><li><a class="tocitem" href="../element_database/">Element Database</a></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Philosophy</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Philosophy</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ahojukka5/AbaqusReader.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ahojukka5/AbaqusReader.jl/blob/master/docs/src/philosophy.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Philosophy:-ABAQUS-as-a-Warning-Example"><a class="docs-heading-anchor" href="#Philosophy:-ABAQUS-as-a-Warning-Example">Philosophy: ABAQUS as a Warning Example</a><a id="Philosophy:-ABAQUS-as-a-Warning-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Philosophy:-ABAQUS-as-a-Warning-Example" title="Permalink"></a></h1><p><img src="../assets/hero-image.webp" alt="ABAQUS Design Philosophy - Separation of Concerns"/></p><h2 id="Our-Position"><a class="docs-heading-anchor" href="#Our-Position">Our Position</a><a id="Our-Position-1"></a><a class="docs-heading-anchor-permalink" href="#Our-Position" title="Permalink"></a></h2><p><strong>ABAQUS element design is a cautionary tale in software engineering.</strong></p><p>From a computer science perspective, ABAQUS demonstrates what happens when you violate separation of concerns and mix orthogonal dimensions into a single type hierarchy. We&#39;re software engineers, and we recognize bad design when we see it - even in commercial products.</p><p><strong>We don&#39;t dance to ABAQUS&#39;s whistle.</strong> We support their format (interoperability) but don&#39;t replicate their architectural mistakes (exponential hell).</p><hr/><h2 id="The-Problem:-Exponential-Complexity"><a class="docs-heading-anchor" href="#The-Problem:-Exponential-Complexity">The Problem: Exponential Complexity</a><a id="The-Problem:-Exponential-Complexity-1"></a><a class="docs-heading-anchor-permalink" href="#The-Problem:-Exponential-Complexity" title="Permalink"></a></h2><p>ABAQUS creates separate element types for every combination of:</p><ul><li><strong>Topology</strong> (3 nodes, 4 nodes, 8 nodes...)</li><li><strong>Physics</strong> (plane stress, plane strain, axisymmetric, 3D...)</li><li><strong>Integration</strong> (full, reduced, selective...)</li><li><strong>Features</strong> (hybrid, incompatible modes, temperature...)</li></ul><h3 id="Example:-The-Triangle-Family"><a class="docs-heading-anchor" href="#Example:-The-Triangle-Family">Example: The Triangle Family</a><a id="Example:-The-Triangle-Family-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-The-Triangle-Family" title="Permalink"></a></h3><pre><code class="nohighlight hljs">CPS3  = 3 nodes + Plane Stress + Standard
CPE3  = 3 nodes + Plane Strain + Standard
CAX3  = 3 nodes + Axisymmetric + Standard
C3D3  = 3 nodes + 3D + Standard
...</code></pre><p>Same 3-node triangle topology, different physics. But ABAQUS treats them as completely different element types.</p><p><strong>Result</strong>: 100+ element types with massive code duplication.</p><h3 id="The-Growth-Pattern"><a class="docs-heading-anchor" href="#The-Growth-Pattern">The Growth Pattern</a><a id="The-Growth-Pattern-1"></a><a class="docs-heading-anchor-permalink" href="#The-Growth-Pattern" title="Permalink"></a></h3><pre><code class="nohighlight hljs">Types = Topologies × Physics × Integration × Features

Example:
  10 topologies × 4 physics × 3 integration × 2 features = 240 types

Adding one topology → Create 24 new variants (4×3×2)
Adding one physics → Create 60 new variants (10×3×2)</code></pre><p>This is <strong>O(exponential)</strong> complexity. Unmaintainable. Unextensible.</p><hr/><h2 id="Why-This-Is-Wrong:-SOLID-Principles-Violated"><a class="docs-heading-anchor" href="#Why-This-Is-Wrong:-SOLID-Principles-Violated">Why This Is Wrong: SOLID Principles Violated</a><a id="Why-This-Is-Wrong:-SOLID-Principles-Violated-1"></a><a class="docs-heading-anchor-permalink" href="#Why-This-Is-Wrong:-SOLID-Principles-Violated" title="Permalink"></a></h2><p>ABAQUS&#39;s element design is a textbook example of <strong>violating every SOLID principle</strong> from object-oriented design. Let&#39;s examine each violation:</p><h3 id="**S**-Single-Responsibility-Principle"><a class="docs-heading-anchor" href="#**S**-Single-Responsibility-Principle"><strong>S</strong> - Single Responsibility Principle ❌</a><a id="**S**-Single-Responsibility-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#**S**-Single-Responsibility-Principle" title="Permalink"></a></h3><p><strong>Principle</strong>: &quot;A class should have one, and only one, reason to change.&quot;</p><p><strong>ABAQUS Violation</strong>: Each element type has multiple responsibilities:</p><ul><li>Topology (geometric shape and connectivity)</li><li>Physics formulation (stress state, material behavior)</li><li>Integration scheme (quadrature rules)</li><li>Special features (hybrid, incompatible modes)</li></ul><pre><code class="language-fortran hljs">! CPS3 is responsible for ALL of these:
SUBROUTINE CPS3_STIFFNESS(...)
  ! Topology: 3-node triangle shape functions
  ! Physics: Plane stress constitutive equations
  ! Integration: Gauss quadrature
  ! Assembly: Element stiffness contribution
END</code></pre><p><strong>Consequence</strong>: Change anything → must modify the entire element type. Want reduced integration? Create <code>CPS3R</code>. Want hybrid formulation? Create <code>CPS3H</code>. Exponential explosion.</p><h3 id="**O**-Open/Closed-Principle"><a class="docs-heading-anchor" href="#**O**-Open/Closed-Principle"><strong>O</strong> - Open/Closed Principle ❌</a><a id="**O**-Open/Closed-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#**O**-Open/Closed-Principle" title="Permalink"></a></h3><p><strong>Principle</strong>: &quot;Software should be open for extension, closed for modification.&quot;</p><p><strong>ABAQUS Violation</strong>: Cannot add new physics without modifying the codebase:</p><pre><code class="nohighlight hljs">Want new physics formulation?
1. Create N new element types (one per topology)
2. Modify element registry
3. Duplicate shape functions and integration
4. Update documentation, tests, manuals</code></pre><p><strong>Modern approach</strong> (extension without modification):</p><pre><code class="language-julia hljs"># Add new physics - zero modifications to existing code
struct HyperelasticFormulation end

function stiffness(elem::Tri3, phys::HyperelasticFormulation, integ::FullIntegration)
    # New behavior via multiple dispatch
    # Tri3 code unchanged
end</code></pre><h3 id="**L**-Liskov-Substitution-Principle"><a class="docs-heading-anchor" href="#**L**-Liskov-Substitution-Principle"><strong>L</strong> - Liskov Substitution Principle ❌</a><a id="**L**-Liskov-Substitution-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#**L**-Liskov-Substitution-Principle" title="Permalink"></a></h3><p><strong>Principle</strong>: &quot;Derived classes must be substitutable for their base classes.&quot;</p><p><strong>ABAQUS Violation</strong>: Cannot substitute <code>CPS3</code> for <code>CPE3</code> even though they&#39;re the same topology:</p><pre><code class="language-fortran hljs">! These SHOULD be interchangeable (same topology)
! But they&#39;re not - different physics hardcoded
CALL ELEMENT_STIFFNESS(elem_type=&#39;CPS3&#39;, ...)  ! Plane stress
CALL ELEMENT_STIFFNESS(elem_type=&#39;CPE3&#39;, ...)  ! Plane strain

! Cannot substitute! Different hardcoded behavior</code></pre><p><strong>Modern approach</strong> (proper substitution):</p><pre><code class="language-julia hljs"># Same topology, different physics - fully substitutable
function solve(topology::Triangle3Node, physics::PhysicsModel)
    # Topology is substitutable, physics is parameter
end

solve(Tri3([1,2,3]), PlaneStress())   # ✓ Works
solve(Tri3([1,2,3]), PlaneStrain())   # ✓ Same topology, different physics</code></pre><h3 id="**I**-Interface-Segregation-Principle"><a class="docs-heading-anchor" href="#**I**-Interface-Segregation-Principle"><strong>I</strong> - Interface Segregation Principle ❌</a><a id="**I**-Interface-Segregation-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#**I**-Interface-Segregation-Principle" title="Permalink"></a></h3><p><strong>Principle</strong>: &quot;Clients shouldn&#39;t depend on interfaces they don&#39;t use.&quot;</p><p><strong>ABAQUS Violation</strong>: Element types expose everything even when only topology is needed:</p><pre><code class="language-fortran hljs">! Just need connectivity for visualization
CALL GET_ELEMENT_NODES(elem_type=&#39;C3D20&#39;, ...)

! But C3D20 includes:
! - 20-node hexahedron topology          (NEEDED)
! - 3D stress formulation                (NOT NEEDED)
! - Quadratic shape functions            (NOT NEEDED)
! - Integration point data               (NOT NEEDED)
! - Material interface                   (NOT NEEDED)

! Fat interface - 80% irrelevant for this use case</code></pre><p><strong>Modern approach</strong> (segregated interfaces):</p><pre><code class="language-julia hljs"># Topology interface (what AbaqusReader provides)
topology = Hex20([1,2,3,...,20])  # Just connectivity
nodes = get_nodes(topology)        # Simple, focused interface

# Physics interface (user adds if needed)
physics = ThreeDimensionalStress()
stiffness = compute(topology, physics)  # Separate concerns</code></pre><h3 id="**D**-Dependency-Inversion-Principle"><a class="docs-heading-anchor" href="#**D**-Dependency-Inversion-Principle"><strong>D</strong> - Dependency Inversion Principle ❌</a><a id="**D**-Dependency-Inversion-Principle-1"></a><a class="docs-heading-anchor-permalink" href="#**D**-Dependency-Inversion-Principle" title="Permalink"></a></h3><p><strong>Principle</strong>: &quot;Depend on abstractions, not concretions.&quot;</p><p><strong>ABAQUS Violation</strong>: Everything depends on concrete element type names:</p><pre><code class="language-fortran hljs">! Tight coupling to concrete types
IF (elem_type == &#39;CPS3&#39;) THEN
  CALL CPS3_ROUTINE(...)
ELSEIF (elem_type == &#39;CPE3&#39;) THEN
  CALL CPE3_ROUTINE(...)
ELSEIF (elem_type == &#39;CAX3&#39;) THEN
  CALL CAX3_ROUTINE(...)
! ... 240+ more cases
ENDIF

! Cannot abstract! Concrete type names everywhere</code></pre><p><strong>Modern approach</strong> (depend on abstractions):</p><pre><code class="language-julia hljs"># Abstract interfaces
abstract type Element end
abstract type Physics end

# Concrete implementations
struct Tri3 &lt;: Element end
struct PlaneStress &lt;: Physics end

# Depend on abstraction, not concretions
function stiffness(elem::Element, phys::Physics)
    # Works with ANY element and physics type
    # Multiple dispatch resolves concrete behavior
end</code></pre><hr/><h2 id="SOLID-Violations-Summary"><a class="docs-heading-anchor" href="#SOLID-Violations-Summary">SOLID Violations Summary</a><a id="SOLID-Violations-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#SOLID-Violations-Summary" title="Permalink"></a></h2><table><tr><th style="text-align: right"><strong>Principle</strong></th><th style="text-align: right"><strong>ABAQUS Violation</strong></th><th style="text-align: right"><strong>Consequence</strong></th></tr><tr><td style="text-align: right"><strong>S</strong>ingle Responsibility</td><td style="text-align: right">Element types do topology + physics + integration</td><td style="text-align: right">Change one aspect → modify entire type</td></tr><tr><td style="text-align: right"><strong>O</strong>pen/Closed</td><td style="text-align: right">Cannot extend without modifying codebase</td><td style="text-align: right">Adding features requires code changes</td></tr><tr><td style="text-align: right"><strong>L</strong>iskov Substitution</td><td style="text-align: right">Same topology types not substitutable</td><td style="text-align: right">Cannot abstract over topology</td></tr><tr><td style="text-align: right"><strong>I</strong>nterface Segregation</td><td style="text-align: right">Fat interfaces expose everything</td><td style="text-align: right">Clients depend on unused functionality</td></tr><tr><td style="text-align: right"><strong>D</strong>ependency Inversion</td><td style="text-align: right">Depends on concrete type names</td><td style="text-align: right">Tight coupling, hard to abstract</td></tr></table><p><strong>Result</strong>: <strong>Unmaintainable, unextensible, O(exponential) complexity.</strong></p><hr/><h2 id="Additional-Design-Violations"><a class="docs-heading-anchor" href="#Additional-Design-Violations">Additional Design Violations</a><a id="Additional-Design-Violations-1"></a><a class="docs-heading-anchor-permalink" href="#Additional-Design-Violations" title="Permalink"></a></h2><h3 id="Violates-Separation-of-Concerns"><a class="docs-heading-anchor" href="#Violates-Separation-of-Concerns">Violates Separation of Concerns</a><a id="Violates-Separation-of-Concerns-1"></a><a class="docs-heading-anchor-permalink" href="#Violates-Separation-of-Concerns" title="Permalink"></a></h3><p>Topology and physics are <strong>orthogonal</strong> - they vary independently, but ABAQUS couples them.</p><h3 id="Violates-DRY-(Don&#39;t-Repeat-Yourself)"><a class="docs-heading-anchor" href="#Violates-DRY-(Don&#39;t-Repeat-Yourself)">Violates DRY (Don&#39;t Repeat Yourself)</a><a id="Violates-DRY-(Don&#39;t-Repeat-Yourself)-1"></a><a class="docs-heading-anchor-permalink" href="#Violates-DRY-(Don&#39;t-Repeat-Yourself)" title="Permalink"></a></h3><pre><code class="language-fortran hljs">! Same shape functions duplicated across physics variants
SUBROUTINE CPS3_STIFFNESS(...)
  ! Shape functions for 3-node triangle
END

SUBROUTINE CPE3_STIFFNESS(...)
  ! Shape functions for 3-node triangle  (DUPLICATED!)
END

SUBROUTINE CAX3_STIFFNESS(...)
  ! Shape functions for 3-node triangle  (DUPLICATED!)
END</code></pre><h3 id="Not-Composable"><a class="docs-heading-anchor" href="#Not-Composable">Not Composable</a><a id="Not-Composable-1"></a><a class="docs-heading-anchor-permalink" href="#Not-Composable" title="Permalink"></a></h3><p>Modern software composes behavior:</p><pre><code class="nohighlight hljs">stiffness = topology ∘ physics ∘ integration</code></pre><p>ABAQUS has monolithic types instead. No composition, no reuse.</p><hr/><h2 id="The-Modern-Solution:-Separation-via-Type-Systems"><a class="docs-heading-anchor" href="#The-Modern-Solution:-Separation-via-Type-Systems">The Modern Solution: Separation via Type Systems</a><a id="The-Modern-Solution:-Separation-via-Type-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#The-Modern-Solution:-Separation-via-Type-Systems" title="Permalink"></a></h2><h3 id="What-We-Should-Do-(Julia-Multiple-Dispatch)"><a class="docs-heading-anchor" href="#What-We-Should-Do-(Julia-Multiple-Dispatch)">What We Should Do (Julia Multiple Dispatch)</a><a id="What-We-Should-Do-(Julia-Multiple-Dispatch)-1"></a><a class="docs-heading-anchor-permalink" href="#What-We-Should-Do-(Julia-Multiple-Dispatch)" title="Permalink"></a></h3><pre><code class="language-julia hljs"># Define concerns independently
struct Tri3 
    nodes::Vector{Int}  # Topology only - geometry
end

struct Quad4
    nodes::Vector{Int}
end

# Physics formulations - separate types
struct PlaneStress end
struct PlaneStrain end
struct Axisymmetric end

# Integration schemes - separate types
struct FullIntegration end
struct ReducedIntegration end

# Compose via multiple dispatch
function stiffness(elem::Tri3, phys::PlaneStress, integ::FullIntegration)
    # Only this specific combination
end

function stiffness(elem::Tri3, phys::PlaneStrain, integ::FullIntegration)
    # Different physics, same topology - reuses Tri3 shape functions
end

# Extensibility: Add new physics without touching topology
struct NonlinearElastic end

function stiffness(elem::Tri3, phys::NonlinearElastic, integ::FullIntegration)
    # New physics, existing topology - zero modifications to Tri3 code
end</code></pre><p><strong>Complexity</strong>: O(T + P + I) types instead of O(T × P × I)</p><p><strong>Result</strong>: 19 types instead of 240</p><h3 id="C-Templates"><a class="docs-heading-anchor" href="#C-Templates">C++ Templates</a><a id="C-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#C-Templates" title="Permalink"></a></h3><pre><code class="language-cpp hljs">// Topology
template&lt;int N&gt;
class Triangle { 
    std::array&lt;int, N&gt; nodes; 
};

// Compose at compile time
template&lt;typename Physics, typename Integration&gt;
Matrix stiffness(Triangle&lt;3&gt;&amp; elem, Physics p, Integration i) {
    // Specialized per combination
    // Zero runtime overhead
}

// Extensibility: Add new physics
struct NewPhysics { };

// Automatically works with all topologies!</code></pre><h3 id="Rust-Traits"><a class="docs-heading-anchor" href="#Rust-Traits">Rust Traits</a><a id="Rust-Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Rust-Traits" title="Permalink"></a></h3><pre><code class="language-rust hljs">// Separate traits for each concern
trait Element {
    fn nodes(&amp;self) -&gt; &amp;[usize];
}

trait Formulation {
    fn stress_state(&amp;self) -&gt; StressState;
}

trait Quadrature {
    fn points(&amp;self) -&gt; Vec&lt;Point&gt;;
}

// Compose orthogonally
fn solve&lt;E: Element, F: Formulation, Q: Quadrature&gt;(
    elem: &amp;E, form: &amp;F, quad: &amp;Q
) {
    // Type system ensures valid combinations
}</code></pre><hr/><h2 id="Why-ABAQUS-Is-This-Way:-Historical-Context"><a class="docs-heading-anchor" href="#Why-ABAQUS-Is-This-Way:-Historical-Context">Why ABAQUS Is This Way: Historical Context</a><a id="Why-ABAQUS-Is-This-Way:-Historical-Context-1"></a><a class="docs-heading-anchor-permalink" href="#Why-ABAQUS-Is-This-Way:-Historical-Context" title="Permalink"></a></h2><h3 id="1970s-FORTRAN-Legacy"><a class="docs-heading-anchor" href="#1970s-FORTRAN-Legacy">1970s FORTRAN Legacy</a><a id="1970s-FORTRAN-Legacy-1"></a><a class="docs-heading-anchor-permalink" href="#1970s-FORTRAN-Legacy" title="Permalink"></a></h3><p>ABAQUS originated in the 1970s when:</p><ul><li>FORTRAN was the dominant language</li><li>Procedural programming was the only paradigm</li><li>Subroutines were the abstraction mechanism</li><li>Templates, traits, and multiple dispatch didn&#39;t exist</li></ul><p><strong>Design consequence</strong>: Each element type = one subroutine. Different behavior = different subroutine.</p><h3 id="Technical-Debt-Accumulation"><a class="docs-heading-anchor" href="#Technical-Debt-Accumulation">Technical Debt Accumulation</a><a id="Technical-Debt-Accumulation-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Debt-Accumulation" title="Permalink"></a></h3><p>After 40+ years:</p><ul><li>Cannot break existing input files (millions of them exist)</li><li>Backward compatibility is absolute requirement</li><li>Refactoring is commercially impossible</li><li>&quot;Add feature&quot; → &quot;add element type&quot; became the pattern</li></ul><p><strong>Result</strong>: Architecture frozen in 1970s paradigm despite modern alternatives.</p><h3 id="Why-Dassault-Didn&#39;t-Fix-It"><a class="docs-heading-anchor" href="#Why-Dassault-Didn&#39;t-Fix-It">Why Dassault Didn&#39;t Fix It</a><a id="Why-Dassault-Didn&#39;t-Fix-It-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Dassault-Didn&#39;t-Fix-It" title="Permalink"></a></h3><ol><li><strong>Legacy inertia</strong> - Too much existing code to refactor</li><li><strong>Backward compatibility trap</strong> - Must support ancient input files</li><li><strong>Feature-driven development</strong> - Add features by adding types, not abstraction</li><li><strong>No architectural vision</strong> - No incentive to refactor what &quot;works&quot;</li></ol><p><strong>ABAQUS is a powerful product with terrible architecture.</strong> A warning example for software engineering education.</p><hr/><h2 id="AbaqusReader&#39;s-Solution"><a class="docs-heading-anchor" href="#AbaqusReader&#39;s-Solution">AbaqusReader&#39;s Solution</a><a id="AbaqusReader&#39;s-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#AbaqusReader&#39;s-Solution" title="Permalink"></a></h2><h3 id="What-We-Do"><a class="docs-heading-anchor" href="#What-We-Do">What We Do</a><a id="What-We-Do-1"></a><a class="docs-heading-anchor-permalink" href="#What-We-Do" title="Permalink"></a></h3><p><strong>We extract topology separately from physics:</strong></p><pre><code class="language-julia hljs">mesh = abaqus_read_mesh(&quot;model.inp&quot;)

# Returns:
mesh[&quot;elements&quot;][1] = [1, 2, 3]              # Connectivity
mesh[&quot;element_types&quot;][1] = :Tri3             # Topological type  
mesh[&quot;element_codes&quot;][1] = :CPS3             # Original ABAQUS name</code></pre><p><strong>Users compose their own physics:</strong></p><pre><code class="language-julia hljs"># User&#39;s FEM code
elem = Tri3(mesh[&quot;elements&quot;][1])
code = mesh[&quot;element_codes&quot;][1]  # :CPS3 tells us it was plane stress

physics = if code == :CPS3
    PlaneStress()
elseif code == :CPE3
    PlaneStrain()
else
    error(&quot;Unknown physics for $code&quot;)
end

K = stiffness(elem, physics)  # Clean composition</code></pre><h3 id="Why-This-Is-Correct"><a class="docs-heading-anchor" href="#Why-This-Is-Correct">Why This Is Correct</a><a id="Why-This-Is-Correct-1"></a><a class="docs-heading-anchor-permalink" href="#Why-This-Is-Correct" title="Permalink"></a></h3><ol><li><strong>Separation of concerns</strong> - Topology independent of physics</li><li><strong>Linear complexity</strong> - 15 topological types vs. ABAQUS&#39;s 100+</li><li><strong>Extensible</strong> - Add physics without touching topology code</li><li><strong>Composable</strong> - Users build behavior from orthogonal pieces</li><li><strong>Modern</strong> - Uses Julia&#39;s type system properly</li></ol><h3 id="What-We-Preserve"><a class="docs-heading-anchor" href="#What-We-Preserve">What We Preserve</a><a id="What-We-Preserve-1"></a><a class="docs-heading-anchor-permalink" href="#What-We-Preserve" title="Permalink"></a></h3><ul><li>✓ Original ABAQUS element names in <code>element_codes</code> (full traceability)</li><li>✓ Node connectivity and numbering</li><li>✓ Element sets and surfaces</li><li>✓ Material names (but not properties - that&#39;s physics)</li></ul><h3 id="What-We-Don&#39;t-Replicate"><a class="docs-heading-anchor" href="#What-We-Don&#39;t-Replicate">What We Don&#39;t Replicate</a><a id="What-We-Don&#39;t-Replicate-1"></a><a class="docs-heading-anchor-permalink" href="#What-We-Don&#39;t-Replicate" title="Permalink"></a></h3><ul><li>✗ ABAQUS&#39;s element type proliferation</li><li>✗ Coupling topology with physics</li><li>✗ Exponential complexity</li><li>✗ Code duplication</li></ul><p><strong>We&#39;re software engineers. We insulate Julia users from ABAQUS&#39;s architectural problems.</strong></p><hr/><h2 id="For-Educators:-Using-ABAQUS-as-a-Teaching-Example"><a class="docs-heading-anchor" href="#For-Educators:-Using-ABAQUS-as-a-Teaching-Example">For Educators: Using ABAQUS as a Teaching Example</a><a id="For-Educators:-Using-ABAQUS-as-a-Teaching-Example-1"></a><a class="docs-heading-anchor-permalink" href="#For-Educators:-Using-ABAQUS-as-a-Teaching-Example" title="Permalink"></a></h2><p>ABAQUS is a <strong>perfect case study</strong> for teaching software engineering principles because it demonstrates clear violations of established best practices.</p><h3 id="What-This-Demonstrates"><a class="docs-heading-anchor" href="#What-This-Demonstrates">What This Demonstrates</a><a id="What-This-Demonstrates-1"></a><a class="docs-heading-anchor-permalink" href="#What-This-Demonstrates" title="Permalink"></a></h3><ol><li><strong>SOLID Principles</strong> - All five violated in one design</li><li><strong>Separation of Concerns</strong> - Orthogonal dimensions mixed together</li><li><strong>Complexity Analysis</strong> - Exponential vs. linear growth patterns</li><li><strong>Technical Debt</strong> - How poor decisions compound over decades</li><li><strong>Type System Design</strong> - Using language features vs. nomenclature hacks</li><li><strong>Maintainability</strong> - Why extensibility matters from day one</li></ol><h3 id="Design-Review-Questions"><a class="docs-heading-anchor" href="#Design-Review-Questions">Design Review Questions</a><a id="Design-Review-Questions-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Review-Questions" title="Permalink"></a></h3><p>When reviewing any software design, ask these questions:</p><h4 id="1.-**Single-Responsibility**"><a class="docs-heading-anchor" href="#1.-**Single-Responsibility**">1. <strong>Single Responsibility</strong></a><a id="1.-**Single-Responsibility**-1"></a><a class="docs-heading-anchor-permalink" href="#1.-**Single-Responsibility**" title="Permalink"></a></h4><ul><li>Does each class/type have exactly one reason to change?</li><li>Are multiple concerns bundled together?</li><li><strong>ABAQUS Example</strong>: Element types mix topology + physics + integration</li></ul><h4 id="2.-**Open/Closed**"><a class="docs-heading-anchor" href="#2.-**Open/Closed**">2. <strong>Open/Closed</strong></a><a id="2.-**Open/Closed**-1"></a><a class="docs-heading-anchor-permalink" href="#2.-**Open/Closed**" title="Permalink"></a></h4><ul><li>Can I add features without modifying existing code?</li><li>Will adding dimension X require creating N×M variants?</li><li><strong>ABAQUS Example</strong>: New physics → must create N new element types</li></ul><h4 id="3.-**Liskov-Substitution**"><a class="docs-heading-anchor" href="#3.-**Liskov-Substitution**">3. <strong>Liskov Substitution</strong></a><a id="3.-**Liskov-Substitution**-1"></a><a class="docs-heading-anchor-permalink" href="#3.-**Liskov-Substitution**" title="Permalink"></a></h4><ul><li>Are similar types truly interchangeable?</li><li>Can I abstract over categories?</li><li><strong>ABAQUS Example</strong>: CPS3 and CPE3 both triangles, but not substitutable</li></ul><h4 id="4.-**Interface-Segregation**"><a class="docs-heading-anchor" href="#4.-**Interface-Segregation**">4. <strong>Interface Segregation</strong></a><a id="4.-**Interface-Segregation**-1"></a><a class="docs-heading-anchor-permalink" href="#4.-**Interface-Segregation**" title="Permalink"></a></h4><ul><li>Do clients depend on functionality they don&#39;t use?</li><li>Are interfaces fat or focused?</li><li><strong>ABAQUS Example</strong>: Need topology? Get physics too (unwanted)</li></ul><h4 id="5.-**Dependency-Inversion**"><a class="docs-heading-anchor" href="#5.-**Dependency-Inversion**">5. <strong>Dependency Inversion</strong></a><a id="5.-**Dependency-Inversion**-1"></a><a class="docs-heading-anchor-permalink" href="#5.-**Dependency-Inversion**" title="Permalink"></a></h4><ul><li>Do I depend on abstractions or concrete types?</li><li>Am I coupled to specific implementations?</li><li><strong>ABAQUS Example</strong>: Hardcoded element type name strings everywhere</li></ul><h4 id="6.-**Are-Concerns-Orthogonal?**"><a class="docs-heading-anchor" href="#6.-**Are-Concerns-Orthogonal?**">6. <strong>Are Concerns Orthogonal?</strong></a><a id="6.-**Are-Concerns-Orthogonal?**-1"></a><a class="docs-heading-anchor-permalink" href="#6.-**Are-Concerns-Orthogonal?**" title="Permalink"></a></h4><ul><li>Do these dimensions vary independently?</li><li>If YES → Separate types that compose</li><li>If NO → Single abstraction may be OK</li><li><strong>ABAQUS Example</strong>: Topology and physics are orthogonal but coupled</li></ul><h4 id="7.-**Am-I-Creating-Exponential-Complexity?**"><a class="docs-heading-anchor" href="#7.-**Am-I-Creating-Exponential-Complexity?**">7. <strong>Am I Creating Exponential Complexity?</strong></a><a id="7.-**Am-I-Creating-Exponential-Complexity?**-1"></a><a class="docs-heading-anchor-permalink" href="#7.-**Am-I-Creating-Exponential-Complexity?**" title="Permalink"></a></h4><ul><li>Will adding dimension X require variants of all Y?</li><li>If YES → You&#39;re creating exponential explosion</li><li>If NO → Good, concerns are separated</li><li><strong>ABAQUS Example</strong>: T × P × I × F = 240+ types</li></ul><h3 id="The-Lessons"><a class="docs-heading-anchor" href="#The-Lessons">The Lessons</a><a id="The-Lessons-1"></a><a class="docs-heading-anchor-permalink" href="#The-Lessons" title="Permalink"></a></h3><table><tr><th style="text-align: right"><strong>❌ Don&#39;t Do This (ABAQUS)</strong></th><th style="text-align: right"><strong>✅ Do This (Modern)</strong></th></tr><tr><td style="text-align: right">Violate all five SOLID principles</td><td style="text-align: right">Follow SOLID for maintainability</td></tr><tr><td style="text-align: right">Mix orthogonal concerns in type names</td><td style="text-align: right">Separate concerns into independent types</td></tr><tr><td style="text-align: right">Use nomenclature instead of type system</td><td style="text-align: right">Use language features (templates/traits/dispatch)</td></tr><tr><td style="text-align: right">Duplicate code across variants</td><td style="text-align: right">Compose at call site</td></tr><tr><td style="text-align: right">Create O(exponential) type proliferation</td><td style="text-align: right">Design for O(linear) extensibility</td></tr><tr><td style="text-align: right">Design for immediate needs only</td><td style="text-align: right">Design for growth from day one</td></tr><tr><td style="text-align: right">Let compatibility prevent improvement</td><td style="text-align: right">Refactor early before debt compounds</td></tr><tr><td style="text-align: right">Depend on concrete type names</td><td style="text-align: right">Depend on abstractions</td></tr></table><h3 id="Teaching-Exercise"><a class="docs-heading-anchor" href="#Teaching-Exercise">Teaching Exercise</a><a id="Teaching-Exercise-1"></a><a class="docs-heading-anchor-permalink" href="#Teaching-Exercise" title="Permalink"></a></h3><p><strong>Give students this scenario</strong>: &quot;You&#39;re designing a FEM library. You need to support:</p><ul><li>10 element topologies (triangles, quads, tets, hexes, etc.)</li><li>5 physics formulations (plane stress, plane strain, 3D, axisymmetric, shells)</li><li>3 integration schemes (full, reduced, selective)</li><li>2 special features (hybrid, incompatible modes)</li></ul><p><strong>Bad approach (ABAQUS style)</strong>: Create 10 × 5 × 3 × 2 = <strong>300 element type classes</strong></p><p><strong>Good approach (modern style)</strong>: Create 10 + 5 + 3 + 2 = <strong>20 types that compose</strong></p><p><strong>Discussion points</strong>:</p><ul><li>Which violates SOLID? (Bad approach violates all five)</li><li>Which is easier to extend? (Good approach: add one type, not 60)</li><li>Which has less code duplication? (Good approach: DRY)</li><li>What happens when you add dimension 5? (Bad: 300→1500 types, Good: 20→25 types)</li></ul><hr/><h2 id="Summary:-ABAQUS-as-a-Warning"><a class="docs-heading-anchor" href="#Summary:-ABAQUS-as-a-Warning">Summary: ABAQUS as a Warning</a><a id="Summary:-ABAQUS-as-a-Warning-1"></a><a class="docs-heading-anchor-permalink" href="#Summary:-ABAQUS-as-a-Warning" title="Permalink"></a></h2><table><tr><th style="text-align: right">Aspect</th><th style="text-align: right">ABAQUS (Wrong)</th><th style="text-align: right">Modern Approach (Right)</th></tr><tr><td style="text-align: right"><strong>SOLID Principles</strong></td><td style="text-align: right">Violates all five</td><td style="text-align: right">Follows all five</td></tr><tr><td style="text-align: right"><strong>Concerns</strong></td><td style="text-align: right">Mixed in type names</td><td style="text-align: right">Separated into types</td></tr><tr><td style="text-align: right"><strong>Complexity</strong></td><td style="text-align: right">O(exponential)</td><td style="text-align: right">O(linear)</td></tr><tr><td style="text-align: right"><strong>Extensibility</strong></td><td style="text-align: right">Modify + duplicate</td><td style="text-align: right">Extend via composition</td></tr><tr><td style="text-align: right"><strong>Code Reuse</strong></td><td style="text-align: right">Heavy duplication</td><td style="text-align: right">Single implementation</td></tr><tr><td style="text-align: right"><strong>Paradigm</strong></td><td style="text-align: right">1970s procedural</td><td style="text-align: right">Modern functional/OOP</td></tr><tr><td style="text-align: right"><strong>Type System</strong></td><td style="text-align: right">Nomenclature-based</td><td style="text-align: right">Language feature-based</td></tr></table><h3 id="Bottom-Line"><a class="docs-heading-anchor" href="#Bottom-Line">Bottom Line</a><a id="Bottom-Line-1"></a><a class="docs-heading-anchor-permalink" href="#Bottom-Line" title="Permalink"></a></h3><p><strong>ABAQUS demonstrates what NOT to do.</strong> Modern languages show how to do it right.</p><p>As proud software engineers, we should call out bad design when we see it - even in commercial products. Learn from both.</p><hr/><h2 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h2><ul><li><a href="../elements/">Supported Elements</a> - Complete element type listing</li><li><a href="../examples/">Examples</a> - Usage examples</li><li><a href="../">Home</a> - Quick start guide</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../lessons_learned/">Lessons Learned »</a><div class="flexbox-break"></div><p class="footer-message">AbaqusReader.jl - Modern FEM mesh parser for Julia</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Monday 17 November 2025 16:41">Monday 17 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
